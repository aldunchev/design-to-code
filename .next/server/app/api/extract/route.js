"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/extract/route";
exports.ids = ["app/api/extract/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("assert");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "fs/promises":
/*!******************************!*\
  !*** external "fs/promises" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("fs/promises");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fextract%2Froute&page=%2Fapi%2Fextract%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fextract%2Froute.ts&appDir=%2FUsers%2Faldunchev%2FWork%2FProjectsCode%2FAI%2Fdesign-to-code%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Faldunchev%2FWork%2FProjectsCode%2FAI%2Fdesign-to-code&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fextract%2Froute&page=%2Fapi%2Fextract%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fextract%2Froute.ts&appDir=%2FUsers%2Faldunchev%2FWork%2FProjectsCode%2FAI%2Fdesign-to-code%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Faldunchev%2FWork%2FProjectsCode%2FAI%2Fdesign-to-code&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_aldunchev_Work_ProjectsCode_AI_design_to_code_app_api_extract_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/extract/route.ts */ \"(rsc)/./app/api/extract/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/extract/route\",\n        pathname: \"/api/extract\",\n        filename: \"route\",\n        bundlePath: \"app/api/extract/route\"\n    },\n    resolvedPagePath: \"/Users/aldunchev/Work/ProjectsCode/AI/design-to-code/app/api/extract/route.ts\",\n    nextConfigOutput,\n    userland: _Users_aldunchev_Work_ProjectsCode_AI_design_to_code_app_api_extract_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/extract/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZleHRyYWN0JTJGcm91dGUmcGFnZT0lMkZhcGklMkZleHRyYWN0JTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGZXh0cmFjdCUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmFsZHVuY2hldiUyRldvcmslMkZQcm9qZWN0c0NvZGUlMkZBSSUyRmRlc2lnbi10by1jb2RlJTJGYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj0lMkZVc2VycyUyRmFsZHVuY2hldiUyRldvcmslMkZQcm9qZWN0c0NvZGUlMkZBSSUyRmRlc2lnbi10by1jb2RlJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUM2QjtBQUMxRztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0hBQW1CO0FBQzNDO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFpRTtBQUN6RTtBQUNBO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ3VIOztBQUV2SCIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpZ21hLWRlc2lnbi1leHRyYWN0b3IvPzUyZjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL1VzZXJzL2FsZHVuY2hldi9Xb3JrL1Byb2plY3RzQ29kZS9BSS9kZXNpZ24tdG8tY29kZS9hcHAvYXBpL2V4dHJhY3Qvcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2V4dHJhY3Qvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9leHRyYWN0XCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9leHRyYWN0L3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiL1VzZXJzL2FsZHVuY2hldi9Xb3JrL1Byb2plY3RzQ29kZS9BSS9kZXNpZ24tdG8tY29kZS9hcHAvYXBpL2V4dHJhY3Qvcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2V4dHJhY3Qvcm91dGVcIjtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgc2VydmVySG9va3MsXG4gICAgICAgIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgb3JpZ2luYWxQYXRobmFtZSwgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fextract%2Froute&page=%2Fapi%2Fextract%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fextract%2Froute.ts&appDir=%2FUsers%2Faldunchev%2FWork%2FProjectsCode%2FAI%2Fdesign-to-code%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Faldunchev%2FWork%2FProjectsCode%2FAI%2Fdesign-to-code&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/extract/route.ts":
/*!**********************************!*\
  !*** ./app/api/extract/route.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _src_services_extractor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/src/services/extractor */ \"(rsc)/./src/services/extractor.ts\");\n\n\nasync function POST(request) {\n    try {\n        const body = await request.json();\n        const { fileKey } = body;\n        if (!fileKey) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"File key is required\"\n            }, {\n                status: 400\n            });\n        }\n        // Initialize the extractor service\n        const extractor = new _src_services_extractor__WEBPACK_IMPORTED_MODULE_1__.ExtractorService();\n        // Extract data - using the new method that returns data\n        const result = await extractor.extractDataFromFigma(fileKey);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            data: result\n        });\n    } catch (error) {\n        console.error(\"Extraction error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Failed to extract data from Figma\",\n            message: error instanceof Error ? error.message : \"Unknown error\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2V4dHJhY3Qvcm91dGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXVEO0FBQ0k7QUFFcEQsZUFBZUUsS0FBS0MsT0FBb0I7SUFDN0MsSUFBSTtRQUNGLE1BQU1DLE9BQU8sTUFBTUQsUUFBUUUsSUFBSTtRQUMvQixNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHRjtRQUVwQixJQUFJLENBQUNFLFNBQVM7WUFDWixPQUFPTixxREFBWUEsQ0FBQ0ssSUFBSSxDQUN0QjtnQkFBRUUsT0FBTztZQUF1QixHQUNoQztnQkFBRUMsUUFBUTtZQUFJO1FBRWxCO1FBRUEsbUNBQW1DO1FBQ25DLE1BQU1DLFlBQVksSUFBSVIscUVBQWdCQTtRQUV0Qyx3REFBd0Q7UUFDeEQsTUFBTVMsU0FBUyxNQUFNRCxVQUFVRSxvQkFBb0IsQ0FBQ0w7UUFFcEQsT0FBT04scURBQVlBLENBQUNLLElBQUksQ0FBQztZQUN2Qk8sU0FBUztZQUNUQyxNQUFNSDtRQUNSO0lBRUYsRUFBRSxPQUFPSCxPQUFPO1FBQ2RPLFFBQVFQLEtBQUssQ0FBQyxxQkFBcUJBO1FBQ25DLE9BQU9QLHFEQUFZQSxDQUFDSyxJQUFJLENBQ3RCO1lBQ0VFLE9BQU87WUFDUFEsU0FBU1IsaUJBQWlCUyxRQUFRVCxNQUFNUSxPQUFPLEdBQUc7UUFDcEQsR0FDQTtZQUFFUCxRQUFRO1FBQUk7SUFFbEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpZ21hLWRlc2lnbi1leHRyYWN0b3IvLi9hcHAvYXBpL2V4dHJhY3Qvcm91dGUudHM/Yjc2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInXG5pbXBvcnQgeyBFeHRyYWN0b3JTZXJ2aWNlIH0gZnJvbSAnQC9zcmMvc2VydmljZXMvZXh0cmFjdG9yJ1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xuICB0cnkge1xuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKVxuICAgIGNvbnN0IHsgZmlsZUtleSB9ID0gYm9keVxuXG4gICAgaWYgKCFmaWxlS2V5KSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdGaWxlIGtleSBpcyByZXF1aXJlZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZXh0cmFjdG9yIHNlcnZpY2VcbiAgICBjb25zdCBleHRyYWN0b3IgPSBuZXcgRXh0cmFjdG9yU2VydmljZSgpXG5cbiAgICAvLyBFeHRyYWN0IGRhdGEgLSB1c2luZyB0aGUgbmV3IG1ldGhvZCB0aGF0IHJldHVybnMgZGF0YVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4dHJhY3Rvci5leHRyYWN0RGF0YUZyb21GaWdtYShmaWxlS2V5KVxuXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhOiByZXN1bHRcbiAgICB9KVxuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXh0cmFjdGlvbiBlcnJvcjonLCBlcnJvcilcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7XG4gICAgICAgIGVycm9yOiAnRmFpbGVkIHRvIGV4dHJhY3QgZGF0YSBmcm9tIEZpZ21hJyxcbiAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcidcbiAgICAgIH0sXG4gICAgICB7IHN0YXR1czogNTAwIH1cbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJFeHRyYWN0b3JTZXJ2aWNlIiwiUE9TVCIsInJlcXVlc3QiLCJib2R5IiwianNvbiIsImZpbGVLZXkiLCJlcnJvciIsInN0YXR1cyIsImV4dHJhY3RvciIsInJlc3VsdCIsImV4dHJhY3REYXRhRnJvbUZpZ21hIiwic3VjY2VzcyIsImRhdGEiLCJjb25zb2xlIiwibWVzc2FnZSIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/api/extract/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/config/index.ts":
/*!*****************************!*\
  !*** ./src/config/index.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   validateConfig: () => (/* binding */ validateConfig)\n/* harmony export */ });\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dotenv */ \"(rsc)/./node_modules/dotenv/lib/main.js\");\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dotenv__WEBPACK_IMPORTED_MODULE_0__);\n\ndotenv__WEBPACK_IMPORTED_MODULE_0__.config();\nconst config = {\n    figmaApiToken: process.env.FIGMA_API_TOKEN || \"\",\n    figmaApiBaseUrl: \"https://api.figma.com/v1\"\n};\nfunction validateConfig() {\n    if (!config.figmaApiToken) {\n        throw new Error(\"FIGMA_API_TOKEN environment variable is required\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29uZmlnL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUM7QUFFakNBLDBDQUFhO0FBT04sTUFBTUMsU0FBaUI7SUFDNUJDLGVBQWVDLFFBQVFDLEdBQUcsQ0FBQ0MsZUFBZSxJQUFJO0lBQzlDQyxpQkFBaUI7QUFDbkIsRUFBRTtBQUVLLFNBQVNDO0lBQ2QsSUFBSSxDQUFDTixPQUFPQyxhQUFhLEVBQUU7UUFDekIsTUFBTSxJQUFJTSxNQUFNO0lBQ2xCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maWdtYS1kZXNpZ24tZXh0cmFjdG9yLy4vc3JjL2NvbmZpZy9pbmRleC50cz9kYTkwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGRvdGVudiBmcm9tICdkb3RlbnYnO1xuXG5kb3RlbnYuY29uZmlnKCk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29uZmlnIHtcbiAgZmlnbWFBcGlUb2tlbjogc3RyaW5nO1xuICBmaWdtYUFwaUJhc2VVcmw6IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IGNvbmZpZzogQ29uZmlnID0ge1xuICBmaWdtYUFwaVRva2VuOiBwcm9jZXNzLmVudi5GSUdNQV9BUElfVE9LRU4gfHwgJycsXG4gIGZpZ21hQXBpQmFzZVVybDogJ2h0dHBzOi8vYXBpLmZpZ21hLmNvbS92MSdcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNvbmZpZygpOiB2b2lkIHtcbiAgaWYgKCFjb25maWcuZmlnbWFBcGlUb2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcignRklHTUFfQVBJX1RPS0VOIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIHJlcXVpcmVkJyk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJkb3RlbnYiLCJjb25maWciLCJmaWdtYUFwaVRva2VuIiwicHJvY2VzcyIsImVudiIsIkZJR01BX0FQSV9UT0tFTiIsImZpZ21hQXBpQmFzZVVybCIsInZhbGlkYXRlQ29uZmlnIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/config/index.ts\n");

/***/ }),

/***/ "(rsc)/./src/processors/componentParser.ts":
/*!*******************************************!*\
  !*** ./src/processors/componentParser.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ComponentParser: () => (/* binding */ ComponentParser)\n/* harmony export */ });\nclass ComponentParser {\n    parseComponents(fileData, componentsData) {\n        const components = this.extractComponents(fileData, componentsData);\n        return {\n            components,\n            version: fileData.version,\n            lastModified: fileData.lastModified\n        };\n    }\n    extractComponents(fileData, componentsData) {\n        const extractedComponents = [];\n        // PRIMARY: Extract components from file data (local components)\n        if (fileData.components && typeof fileData.components === \"object\") {\n            const componentKeys = Object.keys(fileData.components);\n            console.log(`🔧 Extracting ${componentKeys.length} components from file data...`);\n            for (const componentId of componentKeys){\n                const component = fileData.components[componentId];\n                const componentSpec = this.analyzeComponentFromFileData(componentId, component, fileData);\n                if (componentSpec) {\n                    extractedComponents.push(componentSpec);\n                }\n            }\n        }\n        // Extract component sets (variants) from file data\n        if (fileData.componentSets && typeof fileData.componentSets === \"object\") {\n            const componentSetKeys = Object.keys(fileData.componentSets);\n            console.log(`📚 Extracting ${componentSetKeys.length} component sets with variants...`);\n            for (const componentSetId of componentSetKeys){\n                const componentSet = fileData.componentSets[componentSetId];\n                const componentSetSpec = this.analyzeComponentSetFromFileData(componentSetId, componentSet, fileData);\n                if (componentSetSpec) {\n                    extractedComponents.push(componentSetSpec);\n                }\n            }\n        }\n        // SECONDARY: Extract components from published API data if available\n        if (componentsData.meta.components && componentsData.meta.components.length > 0) {\n            console.log(`📦 Adding ${componentsData.meta.components.length} published components from API...`);\n            for (const component of componentsData.meta.components){\n                extractedComponents.push({\n                    id: component.key,\n                    name: component.name,\n                    type: \"published-component\",\n                    properties: {\n                        nodeId: component.node_id,\n                        fileKey: component.file_key,\n                        thumbnailUrl: component.thumbnail_url,\n                        createdAt: component.created_at,\n                        updatedAt: component.updated_at\n                    },\n                    description: component.description || `Published component: ${component.name}`\n                });\n            }\n        }\n        // TERTIARY: Extract components from document tree if needed\n        if (extractedComponents.length === 0 && fileData.document) {\n            console.log(`🔍 Searching document tree for components...`);\n            const documentComponents = this.extractComponentsFromDocument(fileData.document);\n            extractedComponents.push(...documentComponents);\n        }\n        // FALLBACK: Sample data only if absolutely no components found\n        if (extractedComponents.length === 0) {\n            console.log(`⚠️  No components found, using sample data...`);\n            extractedComponents.push(...this.getFallbackComponents());\n        }\n        console.log(`✅ Successfully extracted ${extractedComponents.length} total components`);\n        return extractedComponents;\n    }\n    extractComponentsFromDocument(document) {\n        const components = [];\n        // Recursively search for components in the document tree\n        const searchForComponents = (node)=>{\n            if (node.type === \"COMPONENT\" || node.type === \"COMPONENT_SET\") {\n                components.push({\n                    id: node.id,\n                    name: node.name,\n                    type: node.type.toLowerCase(),\n                    properties: {\n                        nodeType: node.type,\n                        visible: node.visible !== false,\n                        absoluteBoundingBox: node.absoluteBoundingBox\n                    },\n                    description: `Component extracted from file: ${node.name}`\n                });\n            }\n            // Recursively search children\n            if (node.children && Array.isArray(node.children)) {\n                for (const child of node.children){\n                    searchForComponents(child);\n                }\n            }\n        };\n        searchForComponents(document);\n        return components;\n    }\n    analyzeComponentFromFileData(componentId, component, fileData) {\n        try {\n            console.log(`🔍 Analyzing component: ${component.name || componentId}`);\n            // Find the actual component node in the document tree\n            const componentNode = this.findComponentNodeInDocument(componentId, fileData.document);\n            let properties = {};\n            if (componentNode) {\n                // Extract properties from the actual node in the document\n                properties = this.extractPropertiesFromComponent(componentNode, fileData);\n                console.log(`✓ Found component node for ${component.name}, extracted ${Object.keys(properties).length} properties`);\n            } else {\n                // Fallback to basic metadata\n                properties = {\n                    componentKey: component.key,\n                    remote: component.remote,\n                    documentationLinks: component.documentationLinks || []\n                };\n                console.log(`⚠️  Component node not found for ${component.name}, using metadata only`);\n            }\n            return {\n                id: componentId,\n                name: component.name || `Component ${componentId}`,\n                type: \"component\",\n                properties,\n                description: component.description || `Local component: ${component.name || componentId}`\n            };\n        } catch (error) {\n            console.log(`⚠️  Error analyzing component ${componentId}:`, error);\n            return null;\n        }\n    }\n    analyzeComponentSetFromFileData(componentSetId, componentSet, fileData) {\n        try {\n            console.log(`🔍 Analyzing component set: ${componentSet.name || componentSetId}`);\n            // Find the actual component set node in the document tree\n            const componentSetNode = this.findComponentNodeInDocument(componentSetId, fileData.document);\n            let properties = {};\n            let variants = {};\n            if (componentSetNode) {\n                // Extract properties from the actual node in the document\n                properties = this.extractPropertiesFromComponent(componentSetNode, fileData);\n                variants = this.extractVariantsFromComponentSet(componentSetNode, fileData);\n                console.log(`✓ Found component set node for ${componentSet.name}, extracted ${Object.keys(properties).length} properties and ${Object.keys(variants).length} variants`);\n            } else {\n                // Fallback to basic metadata\n                properties = {\n                    componentKey: componentSet.key,\n                    remote: componentSet.remote,\n                    documentationLinks: componentSet.documentationLinks || []\n                };\n                console.log(`⚠️  Component set node not found for ${componentSet.name}, using metadata only`);\n            }\n            return {\n                id: componentSetId,\n                name: componentSet.name || `ComponentSet ${componentSetId}`,\n                type: \"component-set\",\n                properties,\n                variants,\n                description: componentSet.description || `Component set with variants: ${componentSet.name || componentSetId}`\n            };\n        } catch (error) {\n            console.log(`⚠️  Error analyzing component set ${componentSetId}:`, error);\n            return null;\n        }\n    }\n    extractPropertiesFromComponent(component, fileData) {\n        const properties = {};\n        // Basic component metadata\n        if (component.type) properties.nodeType = component.type;\n        if (component.visible !== undefined) properties.visible = component.visible;\n        if (component.absoluteBoundingBox) {\n            properties.width = component.absoluteBoundingBox.width;\n            properties.height = component.absoluteBoundingBox.height;\n        }\n        // Layout properties\n        if (component.layoutMode) properties.layoutMode = component.layoutMode;\n        if (component.primaryAxisSizingMode) properties.primaryAxisSizingMode = component.primaryAxisSizingMode;\n        if (component.counterAxisSizingMode) properties.counterAxisSizingMode = component.counterAxisSizingMode;\n        if (component.itemSpacing !== undefined) properties.itemSpacing = component.itemSpacing;\n        // Padding\n        if (component.paddingLeft !== undefined) properties.paddingLeft = component.paddingLeft;\n        if (component.paddingRight !== undefined) properties.paddingRight = component.paddingRight;\n        if (component.paddingTop !== undefined) properties.paddingTop = component.paddingTop;\n        if (component.paddingBottom !== undefined) properties.paddingBottom = component.paddingBottom;\n        // Border radius\n        if (component.cornerRadius !== undefined) properties.cornerRadius = component.cornerRadius;\n        if (component.rectangleCornerRadii) properties.cornerRadii = component.rectangleCornerRadii;\n        // Fill and stroke\n        if (component.fills && component.fills.length > 0) {\n            properties.fills = component.fills.map((fill)=>({\n                    type: fill.type,\n                    color: fill.color ? this.rgbToHex(fill.color) : undefined,\n                    opacity: fill.opacity\n                }));\n        }\n        if (component.strokes && component.strokes.length > 0) {\n            properties.strokes = component.strokes.map((stroke)=>({\n                    type: stroke.type,\n                    color: stroke.color ? this.rgbToHex(stroke.color) : undefined,\n                    opacity: stroke.opacity\n                }));\n        }\n        if (component.strokeWeight !== undefined) properties.strokeWeight = component.strokeWeight;\n        // Effects\n        if (component.effects && component.effects.length > 0) {\n            properties.effects = component.effects.map((effect)=>({\n                    type: effect.type,\n                    visible: effect.visible,\n                    radius: effect.radius,\n                    color: effect.color ? this.rgbaToString(effect.color) : undefined,\n                    offset: effect.offset\n                }));\n        }\n        // Text properties (if it's a text component)\n        if (component.style) {\n            properties.textStyle = {\n                fontFamily: component.style.fontFamily,\n                fontSize: component.style.fontSize,\n                fontWeight: component.style.fontWeight,\n                lineHeight: component.style.lineHeightPx || component.style.lineHeightPercent,\n                letterSpacing: component.style.letterSpacing,\n                textCase: component.style.textCase\n            };\n        }\n        return properties;\n    }\n    extractVariantsFromComponentSet(componentSet, fileData) {\n        const variants = {};\n        // Extract variant properties from component set\n        if (componentSet.componentPropertyDefinitions) {\n            Object.entries(componentSet.componentPropertyDefinitions).forEach(([propName, propDef])=>{\n                variants[propName] = {\n                    type: propDef.type,\n                    defaultValue: propDef.defaultValue,\n                    variantOptions: propDef.variantOptions || []\n                };\n            });\n        }\n        return variants;\n    }\n    rgbToHex(color) {\n        const toHex = (c)=>{\n            const hex = Math.round(c * 255).toString(16);\n            return hex.length === 1 ? \"0\" + hex : hex;\n        };\n        return `#${toHex(color.r)}${toHex(color.g)}${toHex(color.b)}`.toUpperCase();\n    }\n    rgbaToString(color) {\n        const r = Math.round(color.r * 255);\n        const g = Math.round(color.g * 255);\n        const b = Math.round(color.b * 255);\n        const a = color.a !== undefined ? color.a : 1;\n        return `rgba(${r}, ${g}, ${b}, ${a})`;\n    }\n    getFallbackComponents() {\n        return [\n            {\n                id: \"button-component\",\n                name: \"Button\",\n                type: \"component\",\n                properties: {\n                    variant: [\n                        \"primary\",\n                        \"secondary\",\n                        \"outline\"\n                    ],\n                    size: [\n                        \"sm\",\n                        \"md\",\n                        \"lg\"\n                    ],\n                    disabled: \"boolean\",\n                    text: \"string\"\n                },\n                description: \"Primary button component with multiple variants\"\n            },\n            {\n                id: \"input-component\",\n                name: \"Input\",\n                type: \"component\",\n                properties: {\n                    type: [\n                        \"text\",\n                        \"email\",\n                        \"password\"\n                    ],\n                    placeholder: \"string\",\n                    disabled: \"boolean\",\n                    required: \"boolean\"\n                },\n                description: \"Input field component\"\n            },\n            {\n                id: \"card-component\",\n                name: \"Card\",\n                type: \"component\",\n                properties: {\n                    elevation: [\n                        \"none\",\n                        \"sm\",\n                        \"md\",\n                        \"lg\"\n                    ],\n                    padding: [\n                        \"sm\",\n                        \"md\",\n                        \"lg\"\n                    ],\n                    rounded: \"boolean\"\n                },\n                description: \"Card container component\"\n            }\n        ];\n    }\n    findComponentNodeInDocument(componentId, document) {\n        // Recursively search for a node with the matching ID\n        const searchForNode = (node)=>{\n            if (node.id === componentId) {\n                return node;\n            }\n            if (node.children && Array.isArray(node.children)) {\n                for (const child of node.children){\n                    const found = searchForNode(child);\n                    if (found) return found;\n                }\n            }\n            return null;\n        };\n        return searchForNode(document);\n    }\n    analyzeComponentNode(node) {\n        // This method is kept for document tree analysis if needed\n        return null;\n    }\n    extractVariants(node) {\n        // This method is kept for backward compatibility\n        return {};\n    }\n    extractProperties(node) {\n        // This method is kept for backward compatibility\n        return {};\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvcHJvY2Vzc29ycy9jb21wb25lbnRQYXJzZXIudHMiLCJtYXBwaW5ncyI6Ijs7OztBQWlCTyxNQUFNQTtJQUNYQyxnQkFBZ0JDLFFBQTJCLEVBQUVDLGNBQXVDLEVBQWtCO1FBQ3BHLE1BQU1DLGFBQWEsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ0gsVUFBVUM7UUFFcEQsT0FBTztZQUNMQztZQUNBRSxTQUFTSixTQUFTSSxPQUFPO1lBQ3pCQyxjQUFjTCxTQUFTSyxZQUFZO1FBQ3JDO0lBQ0Y7SUFFUUYsa0JBQWtCSCxRQUEyQixFQUFFQyxjQUF1QyxFQUFtQjtRQUMvRyxNQUFNSyxzQkFBdUMsRUFBRTtRQUUvQyxnRUFBZ0U7UUFDaEUsSUFBSU4sU0FBU0UsVUFBVSxJQUFJLE9BQU9GLFNBQVNFLFVBQVUsS0FBSyxVQUFVO1lBQ2xFLE1BQU1LLGdCQUFnQkMsT0FBT0MsSUFBSSxDQUFDVCxTQUFTRSxVQUFVO1lBQ3JEUSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxjQUFjLEVBQUVKLGNBQWNLLE1BQU0sQ0FBQyw2QkFBNkIsQ0FBQztZQUVoRixLQUFLLE1BQU1DLGVBQWVOLGNBQWU7Z0JBQ3ZDLE1BQU1PLFlBQVlkLFNBQVNFLFVBQVUsQ0FBQ1csWUFBWTtnQkFDbEQsTUFBTUUsZ0JBQWdCLElBQUksQ0FBQ0MsNEJBQTRCLENBQUNILGFBQWFDLFdBQVdkO2dCQUNoRixJQUFJZSxlQUFlO29CQUNqQlQsb0JBQW9CVyxJQUFJLENBQUNGO2dCQUMzQjtZQUNGO1FBQ0Y7UUFFQSxtREFBbUQ7UUFDbkQsSUFBSWYsU0FBU2tCLGFBQWEsSUFBSSxPQUFPbEIsU0FBU2tCLGFBQWEsS0FBSyxVQUFVO1lBQ3hFLE1BQU1DLG1CQUFtQlgsT0FBT0MsSUFBSSxDQUFDVCxTQUFTa0IsYUFBYTtZQUMzRFIsUUFBUUMsR0FBRyxDQUFDLENBQUMsY0FBYyxFQUFFUSxpQkFBaUJQLE1BQU0sQ0FBQyxnQ0FBZ0MsQ0FBQztZQUV0RixLQUFLLE1BQU1RLGtCQUFrQkQsaUJB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QUVRd0Ysa0JBQWtCeEYsSUFBUyxFQUEwQjtRQUMzRCxpREFBaUQ7UUFDakQsT0FBTyxDQUFDO0lBQ1Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpZ21hLWRlc2lnbi1leHRyYWN0b3IvLi9zcmMvcHJvY2Vzc29ycy9jb21wb25lbnRQYXJzZXIudHM/YTJkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGaWdtYUZpbGVSZXNwb25zZSwgRmlnbWFDb21wb25lbnRzUmVzcG9uc2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9maWdtYS1hcGknO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBvbmVudFNwZWMge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6IHN0cmluZztcbiAgcHJvcGVydGllczogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbiAgdmFyaWFudHM/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wb25lbnRTcGVjcyB7XG4gIGNvbXBvbmVudHM6IENvbXBvbmVudFNwZWNbXTtcbiAgdmVyc2lvbjogc3RyaW5nO1xuICBsYXN0TW9kaWZpZWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIENvbXBvbmVudFBhcnNlciB7XG4gIHBhcnNlQ29tcG9uZW50cyhmaWxlRGF0YTogRmlnbWFGaWxlUmVzcG9uc2UsIGNvbXBvbmVudHNEYXRhOiBGaWdtYUNvbXBvbmVudHNSZXNwb25zZSk6IENvbXBvbmVudFNwZWNzIHtcbiAgICBjb25zdCBjb21wb25lbnRzID0gdGhpcy5leHRyYWN0Q29tcG9uZW50cyhmaWxlRGF0YSwgY29tcG9uZW50c0RhdGEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBvbmVudHMsXG4gICAgICB2ZXJzaW9uOiBmaWxlRGF0YS52ZXJzaW9uLFxuICAgICAgbGFzdE1vZGlmaWVkOiBmaWxlRGF0YS5sYXN0TW9kaWZpZWRcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0Q29tcG9uZW50cyhmaWxlRGF0YTogRmlnbWFGaWxlUmVzcG9uc2UsIGNvbXBvbmVudHNEYXRhOiBGaWdtYUNvbXBvbmVudHNSZXNwb25zZSk6IENvbXBvbmVudFNwZWNbXSB7XG4gICAgY29uc3QgZXh0cmFjdGVkQ29tcG9uZW50czogQ29tcG9uZW50U3BlY1tdID0gW107XG5cbiAgICAvLyBQUklNQVJZOiBFeHRyYWN0IGNvbXBvbmVudHMgZnJvbSBmaWxlIGRhdGEgKGxvY2FsIGNvbXBvbmVudHMpXG4gICAgaWYgKGZpbGVEYXRhLmNvbXBvbmVudHMgJiYgdHlwZW9mIGZpbGVEYXRhLmNvbXBvbmVudHMgPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCBjb21wb25lbnRLZXlzID0gT2JqZWN0LmtleXMoZmlsZURhdGEuY29tcG9uZW50cyk7XG4gICAgICBjb25zb2xlLmxvZyhg8J+UpyBFeHRyYWN0aW5nICR7Y29tcG9uZW50S2V5cy5sZW5ndGh9IGNvbXBvbmVudHMgZnJvbSBmaWxlIGRhdGEuLi5gKTtcblxuICAgICAgZm9yIChjb25zdCBjb21wb25lbnRJZCBvZiBjb21wb25lbnRLZXlzKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGZpbGVEYXRhLmNvbXBvbmVudHNbY29tcG9uZW50SWRdO1xuICAgICAgICBjb25zdCBjb21wb25lbnRTcGVjID0gdGhpcy5hbmFseXplQ29tcG9uZW50RnJvbUZpbGVEYXRhKGNvbXBvbmVudElkLCBjb21wb25lbnQsIGZpbGVEYXRhKTtcbiAgICAgICAgaWYgKGNvbXBvbmVudFNwZWMpIHtcbiAgICAgICAgICBleHRyYWN0ZWRDb21wb25lbnRzLnB1c2goY29tcG9uZW50U3BlYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IGNvbXBvbmVudCBzZXRzICh2YXJpYW50cykgZnJvbSBmaWxlIGRhdGFcbiAgICBpZiAoZmlsZURhdGEuY29tcG9uZW50U2V0cyAmJiB0eXBlb2YgZmlsZURhdGEuY29tcG9uZW50U2V0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudFNldEtleXMgPSBPYmplY3Qua2V5cyhmaWxlRGF0YS5jb21wb25lbnRTZXRzKTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OaIEV4dHJhY3RpbmcgJHtjb21wb25lbnRTZXRLZXlzLmxlbmd0aH0gY29tcG9uZW50IHNldHMgd2l0aCB2YXJpYW50cy4uLmApO1xuXG4gICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudFNldElkIG9mIGNvbXBvbmVudFNldEtleXMpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50U2V0ID0gZmlsZURhdGEuY29tcG9uZW50U2V0c1tjb21wb25lbnRTZXRJZF07XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFNldFNwZWMgPSB0aGlzLmFuYWx5emVDb21wb25lbnRTZXRGcm9tRmlsZURhdGEoY29tcG9uZW50U2V0SWQsIGNvbXBvbmVudFNldCwgZmlsZURhdGEpO1xuICAgICAgICBpZiAoY29tcG9uZW50U2V0U3BlYykge1xuICAgICAgICAgIGV4dHJhY3RlZENvbXBvbmVudHMucHVzaChjb21wb25lbnRTZXRTcGVjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNFQ09OREFSWTogRXh0cmFjdCBjb21wb25lbnRzIGZyb20gcHVibGlzaGVkIEFQSSBkYXRhIGlmIGF2YWlsYWJsZVxuICAgIGlmIChjb21wb25lbnRzRGF0YS5tZXRhLmNvbXBvbmVudHMgJiYgY29tcG9uZW50c0RhdGEubWV0YS5jb21wb25lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OmIEFkZGluZyAke2NvbXBvbmVudHNEYXRhLm1ldGEuY29tcG9uZW50cy5sZW5ndGh9IHB1Ymxpc2hlZCBjb21wb25lbnRzIGZyb20gQVBJLi4uYCk7XG4gICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBjb21wb25lbnRzRGF0YS5tZXRhLmNvbXBvbmVudHMpIHtcbiAgICAgICAgZXh0cmFjdGVkQ29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgICBpZDogY29tcG9uZW50LmtleSxcbiAgICAgICAgICBuYW1lOiBjb21wb25lbnQubmFtZSxcbiAgICAgICAgICB0eXBlOiAncHVibGlzaGVkLWNvbXBvbmVudCcsXG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgbm9kZUlkOiBjb21wb25lbnQubm9kZV9pZCxcbiAgICAgICAgICAgIGZpbGVLZXk6IGNvbXBvbmVudC5maWxlX2tleSxcbiAgICAgICAgICAgIHRodW1ibmFpbFVybDogY29tcG9uZW50LnRodW1ibmFpbF91cmwsXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IGNvbXBvbmVudC5jcmVhdGVkX2F0LFxuICAgICAgICAgICAgdXBkYXRlZEF0OiBjb21wb25lbnQudXBkYXRlZF9hdFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IGNvbXBvbmVudC5kZXNjcmlwdGlvbiB8fCBgUHVibGlzaGVkIGNvbXBvbmVudDogJHtjb21wb25lbnQubmFtZX1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRFUlRJQVJZOiBFeHRyYWN0IGNvbXBvbmVudHMgZnJvbSBkb2N1bWVudCB0cmVlIGlmIG5lZWRlZFxuICAgIGlmIChleHRyYWN0ZWRDb21wb25lbnRzLmxlbmd0aCA9PT0gMCAmJiBmaWxlRGF0YS5kb2N1bWVudCkge1xuICAgICAgY29uc29sZS5sb2coYPCflI0gU2VhcmNoaW5nIGRvY3VtZW50IHRyZWUgZm9yIGNvbXBvbmVudHMuLi5gKTtcbiAgICAgIGNvbnN0IGRvY3VtZW50Q29tcG9uZW50cyA9IHRoaXMuZXh0cmFjdENvbXBvbmVudHNGcm9tRG9jdW1lbnQoZmlsZURhdGEuZG9jdW1lbnQpO1xuICAgICAgZXh0cmFjdGVkQ29tcG9uZW50cy5wdXNoKC4uLmRvY3VtZW50Q29tcG9uZW50cyk7XG4gICAgfVxuXG4gICAgLy8gRkFMTEJBQ0s6IFNhbXBsZSBkYXRhIG9ubHkgaWYgYWJzb2x1dGVseSBubyBjb21wb25lbnRzIGZvdW5kXG4gICAgaWYgKGV4dHJhY3RlZENvbXBvbmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhg4pqg77iPICBObyBjb21wb25lbnRzIGZvdW5kLCB1c2luZyBzYW1wbGUgZGF0YS4uLmApO1xuICAgICAgZXh0cmFjdGVkQ29tcG9uZW50cy5wdXNoKC4uLnRoaXMuZ2V0RmFsbGJhY2tDb21wb25lbnRzKCkpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGDinIUgU3VjY2Vzc2Z1bGx5IGV4dHJhY3RlZCAke2V4dHJhY3RlZENvbXBvbmVudHMubGVuZ3RofSB0b3RhbCBjb21wb25lbnRzYCk7XG4gICAgcmV0dXJuIGV4dHJhY3RlZENvbXBvbmVudHM7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RDb21wb25lbnRzRnJvbURvY3VtZW50KGRvY3VtZW50OiBhbnkpOiBDb21wb25lbnRTcGVjW10ge1xuICAgIGNvbnN0IGNvbXBvbmVudHM6IENvbXBvbmVudFNwZWNbXSA9IFtdO1xuXG4gICAgLy8gUmVjdXJzaXZlbHkgc2VhcmNoIGZvciBjb21wb25lbnRzIGluIHRoZSBkb2N1bWVudCB0cmVlXG4gICAgY29uc3Qgc2VhcmNoRm9yQ29tcG9uZW50cyA9IChub2RlOiBhbnkpID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdDT01QT05FTlQnIHx8IG5vZGUudHlwZSA9PT0gJ0NPTVBPTkVOVF9TRVQnKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh7XG4gICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgIHR5cGU6IG5vZGUudHlwZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIG5vZGVUeXBlOiBub2RlLnR5cGUsXG4gICAgICAgICAgICB2aXNpYmxlOiBub2RlLnZpc2libGUgIT09IGZhbHNlLFxuICAgICAgICAgICAgYWJzb2x1dGVCb3VuZGluZ0JveDogbm9kZS5hYnNvbHV0ZUJvdW5kaW5nQm94XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYENvbXBvbmVudCBleHRyYWN0ZWQgZnJvbSBmaWxlOiAke25vZGUubmFtZX1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWN1cnNpdmVseSBzZWFyY2ggY2hpbGRyZW5cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuICYmIEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgc2VhcmNoRm9yQ29tcG9uZW50cyhjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VhcmNoRm9yQ29tcG9uZW50cyhkb2N1bWVudCk7XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gIH1cblxuICAgICAgcHJpdmF0ZSBhbmFseXplQ29tcG9uZW50RnJvbUZpbGVEYXRhKGNvbXBvbmVudElkOiBzdHJpbmcsIGNvbXBvbmVudDogYW55LCBmaWxlRGF0YTogRmlnbWFGaWxlUmVzcG9uc2UpOiBDb21wb25lbnRTcGVjIHwgbnVsbCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEFuYWx5emluZyBjb21wb25lbnQ6ICR7Y29tcG9uZW50Lm5hbWUgfHwgY29tcG9uZW50SWR9YCk7XG5cbiAgICAgIC8vIEZpbmQgdGhlIGFjdHVhbCBjb21wb25lbnQgbm9kZSBpbiB0aGUgZG9jdW1lbnQgdHJlZVxuICAgICAgY29uc3QgY29tcG9uZW50Tm9kZSA9IHRoaXMuZmluZENvbXBvbmVudE5vZGVJbkRvY3VtZW50KGNvbXBvbmVudElkLCBmaWxlRGF0YS5kb2N1bWVudCk7XG5cbiAgICAgIGxldCBwcm9wZXJ0aWVzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge307XG5cbiAgICAgIGlmIChjb21wb25lbnROb2RlKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgcHJvcGVydGllcyBmcm9tIHRoZSBhY3R1YWwgbm9kZSBpbiB0aGUgZG9jdW1lbnRcbiAgICAgICAgcHJvcGVydGllcyA9IHRoaXMuZXh0cmFjdFByb3BlcnRpZXNGcm9tQ29tcG9uZW50KGNvbXBvbmVudE5vZGUsIGZpbGVEYXRhKTtcbiAgICAgICAgY29uc29sZS5sb2coYOKckyBGb3VuZCBjb21wb25lbnQgbm9kZSBmb3IgJHtjb21wb25lbnQubmFtZX0sIGV4dHJhY3RlZCAke09iamVjdC5rZXlzKHByb3BlcnRpZXMpLmxlbmd0aH0gcHJvcGVydGllc2ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gYmFzaWMgbWV0YWRhdGFcbiAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICBjb21wb25lbnRLZXk6IGNvbXBvbmVudC5rZXksXG4gICAgICAgICAgcmVtb3RlOiBjb21wb25lbnQucmVtb3RlLFxuICAgICAgICAgIGRvY3VtZW50YXRpb25MaW5rczogY29tcG9uZW50LmRvY3VtZW50YXRpb25MaW5rcyB8fCBbXVxuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmxvZyhg4pqg77iPICBDb21wb25lbnQgbm9kZSBub3QgZm91bmQgZm9yICR7Y29tcG9uZW50Lm5hbWV9LCB1c2luZyBtZXRhZGF0YSBvbmx5YCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBjb21wb25lbnRJZCxcbiAgICAgICAgbmFtZTogY29tcG9uZW50Lm5hbWUgfHwgYENvbXBvbmVudCAke2NvbXBvbmVudElkfWAsXG4gICAgICAgIHR5cGU6ICdjb21wb25lbnQnLFxuICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICBkZXNjcmlwdGlvbjogY29tcG9uZW50LmRlc2NyaXB0aW9uIHx8IGBMb2NhbCBjb21wb25lbnQ6ICR7Y29tcG9uZW50Lm5hbWUgfHwgY29tcG9uZW50SWR9YFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coYOKaoO+4jyAgRXJyb3IgYW5hbHl6aW5nIGNvbXBvbmVudCAke2NvbXBvbmVudElkfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAgIHByaXZhdGUgYW5hbHl6ZUNvbXBvbmVudFNldEZyb21GaWxlRGF0YShjb21wb25lbnRTZXRJZDogc3RyaW5nLCBjb21wb25lbnRTZXQ6IGFueSwgZmlsZURhdGE6IEZpZ21hRmlsZVJlc3BvbnNlKTogQ29tcG9uZW50U3BlYyB8IG51bGwge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBBbmFseXppbmcgY29tcG9uZW50IHNldDogJHtjb21wb25lbnRTZXQubmFtZSB8fCBjb21wb25lbnRTZXRJZH1gKTtcblxuICAgICAgLy8gRmluZCB0aGUgYWN0dWFsIGNvbXBvbmVudCBzZXQgbm9kZSBpbiB0aGUgZG9jdW1lbnQgdHJlZVxuICAgICAgY29uc3QgY29tcG9uZW50U2V0Tm9kZSA9IHRoaXMuZmluZENvbXBvbmVudE5vZGVJbkRvY3VtZW50KGNvbXBvbmVudFNldElkLCBmaWxlRGF0YS5kb2N1bWVudCk7XG5cbiAgICAgIGxldCBwcm9wZXJ0aWVzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge307XG4gICAgICBsZXQgdmFyaWFudHM6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fTtcblxuICAgICAgaWYgKGNvbXBvbmVudFNldE5vZGUpIHtcbiAgICAgICAgLy8gRXh0cmFjdCBwcm9wZXJ0aWVzIGZyb20gdGhlIGFjdHVhbCBub2RlIGluIHRoZSBkb2N1bWVudFxuICAgICAgICBwcm9wZXJ0aWVzID0gdGhpcy5leHRyYWN0UHJvcGVydGllc0Zyb21Db21wb25lbnQoY29tcG9uZW50U2V0Tm9kZSwgZmlsZURhdGEpO1xuICAgICAgICB2YXJpYW50cyA9IHRoaXMuZXh0cmFjdFZhcmlhbnRzRnJvbUNvbXBvbmVudFNldChjb21wb25lbnRTZXROb2RlLCBmaWxlRGF0YSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGDinJMgRm91bmQgY29tcG9uZW50IHNldCBub2RlIGZvciAke2NvbXBvbmVudFNldC5uYW1lfSwgZXh0cmFjdGVkICR7T2JqZWN0LmtleXMocHJvcGVydGllcykubGVuZ3RofSBwcm9wZXJ0aWVzIGFuZCAke09iamVjdC5rZXlzKHZhcmlhbnRzKS5sZW5ndGh9IHZhcmlhbnRzYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayB0byBiYXNpYyBtZXRhZGF0YVxuICAgICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgIGNvbXBvbmVudEtleTogY29tcG9uZW50U2V0LmtleSxcbiAgICAgICAgICByZW1vdGU6IGNvbXBvbmVudFNldC5yZW1vdGUsXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbkxpbmtzOiBjb21wb25lbnRTZXQuZG9jdW1lbnRhdGlvbkxpbmtzIHx8IFtdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gIENvbXBvbmVudCBzZXQgbm9kZSBub3QgZm91bmQgZm9yICR7Y29tcG9uZW50U2V0Lm5hbWV9LCB1c2luZyBtZXRhZGF0YSBvbmx5YCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBjb21wb25lbnRTZXRJZCxcbiAgICAgICAgbmFtZTogY29tcG9uZW50U2V0Lm5hbWUgfHwgYENvbXBvbmVudFNldCAke2NvbXBvbmVudFNldElkfWAsXG4gICAgICAgIHR5cGU6ICdjb21wb25lbnQtc2V0JyxcbiAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgdmFyaWFudHMsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBjb21wb25lbnRTZXQuZGVzY3JpcHRpb24gfHwgYENvbXBvbmVudCBzZXQgd2l0aCB2YXJpYW50czogJHtjb21wb25lbnRTZXQubmFtZSB8fCBjb21wb25lbnRTZXRJZH1gXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhg4pqg77iPICBFcnJvciBhbmFseXppbmcgY29tcG9uZW50IHNldCAke2NvbXBvbmVudFNldElkfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RQcm9wZXJ0aWVzRnJvbUNvbXBvbmVudChjb21wb25lbnQ6IGFueSwgZmlsZURhdGE6IEZpZ21hRmlsZVJlc3BvbnNlKTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB7XG4gICAgY29uc3QgcHJvcGVydGllczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuXG4gICAgLy8gQmFzaWMgY29tcG9uZW50IG1ldGFkYXRhXG4gICAgaWYgKGNvbXBvbmVudC50eXBlKSBwcm9wZXJ0aWVzLm5vZGVUeXBlID0gY29tcG9uZW50LnR5cGU7XG4gICAgaWYgKGNvbXBvbmVudC52aXNpYmxlICE9PSB1bmRlZmluZWQpIHByb3BlcnRpZXMudmlzaWJsZSA9IGNvbXBvbmVudC52aXNpYmxlO1xuICAgIGlmIChjb21wb25lbnQuYWJzb2x1dGVCb3VuZGluZ0JveCkge1xuICAgICAgcHJvcGVydGllcy53aWR0aCA9IGNvbXBvbmVudC5hYnNvbHV0ZUJvdW5kaW5nQm94LndpZHRoO1xuICAgICAgcHJvcGVydGllcy5oZWlnaHQgPSBjb21wb25lbnQuYWJzb2x1dGVCb3VuZGluZ0JveC5oZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gTGF5b3V0IHByb3BlcnRpZXNcbiAgICBpZiAoY29tcG9uZW50LmxheW91dE1vZGUpIHByb3BlcnRpZXMubGF5b3V0TW9kZSA9IGNvbXBvbmVudC5sYXlvdXRNb2RlO1xuICAgIGlmIChjb21wb25lbnQucHJpbWFyeUF4aXNTaXppbmdNb2RlKSBwcm9wZXJ0aWVzLnByaW1hcnlBeGlzU2l6aW5nTW9kZSA9IGNvbXBvbmVudC5wcmltYXJ5QXhpc1NpemluZ01vZGU7XG4gICAgaWYgKGNvbXBvbmVudC5jb3VudGVyQXhpc1NpemluZ01vZGUpIHByb3BlcnRpZXMuY291bnRlckF4aXNTaXppbmdNb2RlID0gY29tcG9uZW50LmNvdW50ZXJBeGlzU2l6aW5nTW9kZTtcbiAgICBpZiAoY29tcG9uZW50Lml0ZW1TcGFjaW5nICE9PSB1bmRlZmluZWQpIHByb3BlcnRpZXMuaXRlbVNwYWNpbmcgPSBjb21wb25lbnQuaXRlbVNwYWNpbmc7XG5cbiAgICAvLyBQYWRkaW5nXG4gICAgaWYgKGNvbXBvbmVudC5wYWRkaW5nTGVmdCAhPT0gdW5kZWZpbmVkKSBwcm9wZXJ0aWVzLnBhZGRpbmdMZWZ0ID0gY29tcG9uZW50LnBhZGRpbmdMZWZ0O1xuICAgIGlmIChjb21wb25lbnQucGFkZGluZ1JpZ2h0ICE9PSB1bmRlZmluZWQpIHByb3BlcnRpZXMucGFkZGluZ1JpZ2h0ID0gY29tcG9uZW50LnBhZGRpbmdSaWdodDtcbiAgICBpZiAoY29tcG9uZW50LnBhZGRpbmdUb3AgIT09IHVuZGVmaW5lZCkgcHJvcGVydGllcy5wYWRkaW5nVG9wID0gY29tcG9uZW50LnBhZGRpbmdUb3A7XG4gICAgaWYgKGNvbXBvbmVudC5wYWRkaW5nQm90dG9tICE9PSB1bmRlZmluZWQpIHByb3BlcnRpZXMucGFkZGluZ0JvdHRvbSA9IGNvbXBvbmVudC5wYWRkaW5nQm90dG9tO1xuXG4gICAgLy8gQm9yZGVyIHJhZGl1c1xuICAgIGlmIChjb21wb25lbnQuY29ybmVyUmFkaXVzICE9PSB1bmRlZmluZWQpIHByb3BlcnRpZXMuY29ybmVyUmFkaXVzID0gY29tcG9uZW50LmNvcm5lclJhZGl1cztcbiAgICBpZiAoY29tcG9uZW50LnJlY3RhbmdsZUNvcm5lclJhZGlpKSBwcm9wZXJ0aWVzLmNvcm5lclJhZGlpID0gY29tcG9uZW50LnJlY3RhbmdsZUNvcm5lclJhZGlpO1xuXG4gICAgLy8gRmlsbCBhbmQgc3Ryb2tlXG4gICAgaWYgKGNvbXBvbmVudC5maWxscyAmJiBjb21wb25lbnQuZmlsbHMubGVuZ3RoID4gMCkge1xuICAgICAgcHJvcGVydGllcy5maWxscyA9IGNvbXBvbmVudC5maWxscy5tYXAoKGZpbGw6IGFueSkgPT4gKHtcbiAgICAgICAgdHlwZTogZmlsbC50eXBlLFxuICAgICAgICBjb2xvcjogZmlsbC5jb2xvciA/IHRoaXMucmdiVG9IZXgoZmlsbC5jb2xvcikgOiB1bmRlZmluZWQsXG4gICAgICAgIG9wYWNpdHk6IGZpbGwub3BhY2l0eVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnQuc3Ryb2tlcyAmJiBjb21wb25lbnQuc3Ryb2tlcy5sZW5ndGggPiAwKSB7XG4gICAgICBwcm9wZXJ0aWVzLnN0cm9rZXMgPSBjb21wb25lbnQuc3Ryb2tlcy5tYXAoKHN0cm9rZTogYW55KSA9PiAoe1xuICAgICAgICB0eXBlOiBzdHJva2UudHlwZSxcbiAgICAgICAgY29sb3I6IHN0cm9rZS5jb2xvciA/IHRoaXMucmdiVG9IZXgoc3Ryb2tlLmNvbG9yKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgb3BhY2l0eTogc3Ryb2tlLm9wYWNpdHlcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50LnN0cm9rZVdlaWdodCAhPT0gdW5kZWZpbmVkKSBwcm9wZXJ0aWVzLnN0cm9rZVdlaWdodCA9IGNvbXBvbmVudC5zdHJva2VXZWlnaHQ7XG5cbiAgICAvLyBFZmZlY3RzXG4gICAgaWYgKGNvbXBvbmVudC5lZmZlY3RzICYmIGNvbXBvbmVudC5lZmZlY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHByb3BlcnRpZXMuZWZmZWN0cyA9IGNvbXBvbmVudC5lZmZlY3RzLm1hcCgoZWZmZWN0OiBhbnkpID0+ICh7XG4gICAgICAgIHR5cGU6IGVmZmVjdC50eXBlLFxuICAgICAgICB2aXNpYmxlOiBlZmZlY3QudmlzaWJsZSxcbiAgICAgICAgcmFkaXVzOiBlZmZlY3QucmFkaXVzLFxuICAgICAgICBjb2xvcjogZWZmZWN0LmNvbG9yID8gdGhpcy5yZ2JhVG9TdHJpbmcoZWZmZWN0LmNvbG9yKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgb2Zmc2V0OiBlZmZlY3Qub2Zmc2V0XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLy8gVGV4dCBwcm9wZXJ0aWVzIChpZiBpdCdzIGEgdGV4dCBjb21wb25lbnQpXG4gICAgaWYgKGNvbXBvbmVudC5zdHlsZSkge1xuICAgICAgcHJvcGVydGllcy50ZXh0U3R5bGUgPSB7XG4gICAgICAgIGZvbnRGYW1pbHk6IGNvbXBvbmVudC5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICBmb250U2l6ZTogY29tcG9uZW50LnN0eWxlLmZvbnRTaXplLFxuICAgICAgICBmb250V2VpZ2h0OiBjb21wb25lbnQuc3R5bGUuZm9udFdlaWdodCxcbiAgICAgICAgbGluZUhlaWdodDogY29tcG9uZW50LnN0eWxlLmxpbmVIZWlnaHRQeCB8fCBjb21wb25lbnQuc3R5bGUubGluZUhlaWdodFBlcmNlbnQsXG4gICAgICAgIGxldHRlclNwYWNpbmc6IGNvbXBvbmVudC5zdHlsZS5sZXR0ZXJTcGFjaW5nLFxuICAgICAgICB0ZXh0Q2FzZTogY29tcG9uZW50LnN0eWxlLnRleHRDYXNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0VmFyaWFudHNGcm9tQ29tcG9uZW50U2V0KGNvbXBvbmVudFNldDogYW55LCBmaWxlRGF0YTogRmlnbWFGaWxlUmVzcG9uc2UpOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IHtcbiAgICBjb25zdCB2YXJpYW50czogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuXG4gICAgLy8gRXh0cmFjdCB2YXJpYW50IHByb3BlcnRpZXMgZnJvbSBjb21wb25lbnQgc2V0XG4gICAgaWYgKGNvbXBvbmVudFNldC5jb21wb25lbnRQcm9wZXJ0eURlZmluaXRpb25zKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhjb21wb25lbnRTZXQuY29tcG9uZW50UHJvcGVydHlEZWZpbml0aW9ucykuZm9yRWFjaCgoW3Byb3BOYW1lLCBwcm9wRGVmXTogW3N0cmluZywgYW55XSkgPT4ge1xuICAgICAgICB2YXJpYW50c1twcm9wTmFtZV0gPSB7XG4gICAgICAgICAgdHlwZTogcHJvcERlZi50eXBlLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogcHJvcERlZi5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgdmFyaWFudE9wdGlvbnM6IHByb3BEZWYudmFyaWFudE9wdGlvbnMgfHwgW11cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB2YXJpYW50cztcbiAgfVxuXG4gIHByaXZhdGUgcmdiVG9IZXgoY29sb3I6IHsgcjogbnVtYmVyOyBnOiBudW1iZXI7IGI6IG51bWJlciB9KTogc3RyaW5nIHtcbiAgICBjb25zdCB0b0hleCA9IChjOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGhleCA9IE1hdGgucm91bmQoYyAqIDI1NSkudG9TdHJpbmcoMTYpO1xuICAgICAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXg7XG4gICAgfTtcbiAgICByZXR1cm4gYCMke3RvSGV4KGNvbG9yLnIpfSR7dG9IZXgoY29sb3IuZyl9JHt0b0hleChjb2xvci5iKX1gLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICBwcml2YXRlIHJnYmFUb1N0cmluZyhjb2xvcjogeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyOyBhPzogbnVtYmVyIH0pOiBzdHJpbmcge1xuICAgIGNvbnN0IHIgPSBNYXRoLnJvdW5kKGNvbG9yLnIgKiAyNTUpO1xuICAgIGNvbnN0IGcgPSBNYXRoLnJvdW5kKGNvbG9yLmcgKiAyNTUpO1xuICAgIGNvbnN0IGIgPSBNYXRoLnJvdW5kKGNvbG9yLmIgKiAyNTUpO1xuICAgIGNvbnN0IGEgPSBjb2xvci5hICE9PSB1bmRlZmluZWQgPyBjb2xvci5hIDogMTtcbiAgICByZXR1cm4gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHthfSlgO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRGYWxsYmFja0NvbXBvbmVudHMoKTogQ29tcG9uZW50U3BlY1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBpZDogJ2J1dHRvbi1jb21wb25lbnQnLFxuICAgICAgICBuYW1lOiAnQnV0dG9uJyxcbiAgICAgICAgdHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICB2YXJpYW50OiBbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5JywgJ291dGxpbmUnXSxcbiAgICAgICAgICBzaXplOiBbJ3NtJywgJ21kJywgJ2xnJ10sXG4gICAgICAgICAgZGlzYWJsZWQ6ICdib29sZWFuJyxcbiAgICAgICAgICB0ZXh0OiAnc3RyaW5nJ1xuICAgICAgICB9LFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1ByaW1hcnkgYnV0dG9uIGNvbXBvbmVudCB3aXRoIG11bHRpcGxlIHZhcmlhbnRzJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6ICdpbnB1dC1jb21wb25lbnQnLFxuICAgICAgICBuYW1lOiAnSW5wdXQnLFxuICAgICAgICB0eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHR5cGU6IFsndGV4dCcsICdlbWFpbCcsICdwYXNzd29yZCddLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiAnc3RyaW5nJyxcbiAgICAgICAgICBkaXNhYmxlZDogJ2Jvb2xlYW4nLFxuICAgICAgICAgIHJlcXVpcmVkOiAnYm9vbGVhbidcbiAgICAgICAgfSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdJbnB1dCBmaWVsZCBjb21wb25lbnQnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogJ2NhcmQtY29tcG9uZW50JyxcbiAgICAgICAgbmFtZTogJ0NhcmQnLFxuICAgICAgICB0eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGVsZXZhdGlvbjogWydub25lJywgJ3NtJywgJ21kJywgJ2xnJ10sXG4gICAgICAgICAgcGFkZGluZzogWydzbScsICdtZCcsICdsZyddLFxuICAgICAgICAgIHJvdW5kZWQ6ICdib29sZWFuJ1xuICAgICAgICB9LFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0NhcmQgY29udGFpbmVyIGNvbXBvbmVudCdcbiAgICAgIH1cbiAgICBdO1xuICB9XG5cbiAgICBwcml2YXRlIGZpbmRDb21wb25lbnROb2RlSW5Eb2N1bWVudChjb21wb25lbnRJZDogc3RyaW5nLCBkb2N1bWVudDogYW55KTogYW55IHwgbnVsbCB7XG4gICAgLy8gUmVjdXJzaXZlbHkgc2VhcmNoIGZvciBhIG5vZGUgd2l0aCB0aGUgbWF0Y2hpbmcgSURcbiAgICBjb25zdCBzZWFyY2hGb3JOb2RlID0gKG5vZGU6IGFueSk6IGFueSB8IG51bGwgPT4ge1xuICAgICAgaWYgKG5vZGUuaWQgPT09IGNvbXBvbmVudElkKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbiAmJiBBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIGNvbnN0IGZvdW5kID0gc2VhcmNoRm9yTm9kZShjaGlsZCk7XG4gICAgICAgICAgaWYgKGZvdW5kKSByZXR1cm4gZm91bmQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBzZWFyY2hGb3JOb2RlKGRvY3VtZW50KTtcbiAgfVxuXG4gIHByaXZhdGUgYW5hbHl6ZUNvbXBvbmVudE5vZGUobm9kZTogYW55KTogQ29tcG9uZW50U3BlYyB8IG51bGwge1xuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGtlcHQgZm9yIGRvY3VtZW50IHRyZWUgYW5hbHlzaXMgaWYgbmVlZGVkXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RWYXJpYW50cyhub2RlOiBhbnkpOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IHtcbiAgICAvLyBUaGlzIG1ldGhvZCBpcyBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0UHJvcGVydGllcyhub2RlOiBhbnkpOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IHtcbiAgICAvLyBUaGlzIG1ldGhvZCBpcyBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50UGFyc2VyIiwicGFyc2VDb21wb25lbnRzIiwiZmlsZURhdGEiLCJjb21wb25lbnRzRGF0YSIsImNvbXBvbmVudHMiLCJleHRyYWN0Q29tcG9uZW50cyIsInZlcnNpb24iLCJsYXN0TW9kaWZpZWQiLCJleHRyYWN0ZWRDb21wb25lbnRzIiwiY29tcG9uZW50S2V5cyIsIk9iamVjdCIsImtleXMiLCJjb25zb2xlIiwibG9nIiwibGVuZ3RoIiwiY29tcG9uZW50SWQiLCJjb21wb25lbnQiLCJjb21wb25lbnRTcGVjIiwiYW5hbHl6ZUNvbXBvbmVudEZyb21GaWxlRGF0YSIsInB1c2giLCJjb21wb25lbnRTZXRzIiwiY29tcG9uZW50U2V0S2V5cyIsImNvbXBvbmVudFNldElkIiwiY29tcG9uZW50U2V0IiwiY29tcG9uZW50U2V0U3BlYyIsImFuYWx5emVDb21wb25lbnRTZXRGcm9tRmlsZURhdGEiLCJtZXRhIiwiaWQiLCJrZXkiLCJuYW1lIiwidHlwZSIsInByb3BlcnRpZXMiLCJub2RlSWQiLCJub2RlX2lkIiwiZmlsZUtleSIsImZpbGVfa2V5IiwidGh1bWJuYWlsVXJsIiwidGh1bWJuYWlsX3VybCIsImNyZWF0ZWRBdCIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkQXQiLCJ1cGRhdGVkX2F0IiwiZGVzY3JpcHRpb24iLCJkb2N1bWVudCIsImRvY3VtZW50Q29tcG9uZW50cyIsImV4dHJhY3RDb21wb25lbnRzRnJvbURvY3VtZW50IiwiZ2V0RmFsbGJhY2tDb21wb25lbnRzIiwic2VhcmNoRm9yQ29tcG9uZW50cyIsIm5vZGUiLCJ0b0xvd2VyQ2FzZSIsIm5vZGVUeXBlIiwidmlzaWJsZSIsImFic29sdXRlQm91bmRpbmdCb3giLCJjaGlsZHJlbiIsIkFycmF5IiwiaXNBcnJheSIsImNoaWxkIiwiY29tcG9uZW50Tm9kZSIsImZpbmRDb21wb25lbnROb2RlSW5Eb2N1bWVudCIsImV4dHJhY3RQcm9wZXJ0aWVzRnJvbUNvbXBvbmVudCIsImNvbXBvbmVudEtleSIsInJlbW90ZSIsImRvY3VtZW50YXRpb25MaW5rcyIsImVycm9yIiwiY29tcG9uZW50U2V0Tm9kZSIsInZhcmlhbnRzIiwiZXh0cmFjdFZhcmlhbnRzRnJvbUNvbXBvbmVudFNldCIsInVuZGVmaW5lZCIsIndpZHRoIiwiaGVpZ2h0IiwibGF5b3V0TW9kZSIsInByaW1hcnlBeGlzU2l6aW5nTW9kZSIsImNvdW50ZXJBeGlzU2l6aW5nTW9kZSIsIml0ZW1TcGFjaW5nIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsImNvcm5lclJhZGl1cyIsInJlY3RhbmdsZUNvcm5lclJhZGlpIiwiY29ybmVyUmFkaWkiLCJmaWxscyIsIm1hcCIsImZpbGwiLCJjb2xvciIsInJnYlRvSGV4Iiwib3BhY2l0eSIsInN0cm9rZXMiLCJzdHJva2UiLCJzdHJva2VXZWlnaHQiLCJlZmZlY3RzIiwiZWZmZWN0IiwicmFkaXVzIiwicmdiYVRvU3RyaW5nIiwib2Zmc2V0Iiwic3R5bGUiLCJ0ZXh0U3R5bGUiLCJmb250RmFtaWx5IiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwibGluZUhlaWdodCIsImxpbmVIZWlnaHRQeCIsImxpbmVIZWlnaHRQZXJjZW50IiwibGV0dGVyU3BhY2luZyIsInRleHRDYXNlIiwiY29tcG9uZW50UHJvcGVydHlEZWZpbml0aW9ucyIsImVudHJpZXMiLCJmb3JFYWNoIiwicHJvcE5hbWUiLCJwcm9wRGVmIiwiZGVmYXVsdFZhbHVlIiwidmFyaWFudE9wdGlvbnMiLCJ0b0hleCIsImMiLCJoZXgiLCJNYXRoIiwicm91bmQiLCJ0b1N0cmluZyIsInIiLCJnIiwiYiIsInRvVXBwZXJDYXNlIiwiYSIsInZhcmlhbnQiLCJzaXplIiwiZGlzYWJsZWQiLCJ0ZXh0IiwicGxhY2Vob2xkZXIiLCJyZXF1aXJlZCIsImVsZXZhdGlvbiIsInBhZGRpbmciLCJyb3VuZGVkIiwic2VhcmNoRm9yTm9kZSIsImZvdW5kIiwiYW5hbHl6ZUNvbXBvbmVudE5vZGUiLCJleHRyYWN0VmFyaWFudHMiLCJleHRyYWN0UHJvcGVydGllcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/processors/componentParser.ts\n");

/***/ }),

/***/ "(rsc)/./src/processors/tokenParser.ts":
/*!***************************************!*\
  !*** ./src/processors/tokenParser.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TokenParser: () => (/* binding */ TokenParser)\n/* harmony export */ });\nclass TokenParser {\n    parseTokens(fileData, stylesData, variablesData) {\n        console.log(\"\\uD83C\\uDFA8 Extracting design tokens from published styles and variables...\");\n        const tokens = {\n            color: this.extractColorsFromVariables(variablesData, fileData, stylesData),\n            typography: this.extractTypographyFromVariables(variablesData, fileData, stylesData),\n            spacing: this.extractSpacingFromVariables(variablesData),\n            effects: this.extractEffectsFromStyles(fileData, stylesData),\n            borderRadius: this.extractBorderRadiusFromVariables(variablesData),\n            strokeWeight: this.extractStrokeWeightsFromVariables(variablesData)\n        };\n        console.log(\"✅ Design system extraction complete\");\n        return tokens;\n    }\n    extractColorsFromStyles(fileData, stylesData) {\n        const colors = {};\n        // Extract colors from published fill styles (primary source of truth)\n        const fillStyles = stylesData.meta.styles.filter((style)=>style.style_type === \"FILL\");\n        if (fillStyles.length > 0) {\n            console.log(`🎨 Found ${fillStyles.length} published color styles`);\n            for (const style of fillStyles){\n                const hierarchicalName = this.preserveDesignHierarchy(style.name);\n                const colorValue = this.extractColorFromStyle(style, fileData);\n                if (colorValue) {\n                    colors[hierarchicalName] = colorValue;\n                }\n            }\n        }\n        // Extract colors from Variables (if available in file)\n        // This is handled by the main extractColorsFromVariables method now\n        // const variableColors = this.extractColorsFromVariables(fileData);\n        // Object.assign(colors, variableColors);\n        console.log(`📊 Extracted ${Object.keys(colors).length} color tokens from design system`);\n        return Object.keys(colors).length > 0 ? colors : this.getFallbackColors();\n    }\n    extractColorsFromVariables(variablesData, fileData, stylesData) {\n        const colors = {};\n        // Extract colors from Variables API (primary source of truth)\n        if (variablesData.meta.variables) {\n            console.log(`🎨 Processing ${Object.keys(variablesData.meta.variables).length} variables for colors...`);\n            Object.entries(variablesData.meta.variables).forEach(([variableId, variable])=>{\n                if (variable.resolvedType === \"COLOR\") {\n                    const hierarchicalName = this.preserveDesignHierarchy(variable.name);\n                    const colorValue = this.extractColorFromVariable(variable, variablesData);\n                    if (colorValue) {\n                        colors[hierarchicalName] = colorValue;\n                        console.log(`✓ Found color variable: ${variable.name} = ${colorValue}`);\n                    }\n                }\n            });\n        }\n        // Fallback to published styles if no variables found\n        if (Object.keys(colors).length === 0) {\n            console.log(\"\\uD83D\\uDCCE No color variables found, falling back to published styles...\");\n            const fallbackColors = this.extractColorsFromStyles(fileData, stylesData);\n            return Object.keys(fallbackColors).length > 0 ? fallbackColors : this.getFallbackColors();\n        }\n        console.log(`📊 Extracted ${Object.keys(colors).length} color tokens from variables`);\n        return colors;\n    }\n    extractColorFromVariable(variable, variablesData) {\n        try {\n            // Get the default mode from the variable collection\n            const collection = variablesData.meta.variableCollections[variable.variableCollectionId];\n            if (!collection) return null;\n            const defaultModeId = collection.defaultModeId;\n            const colorValue = variable.valuesByMode[defaultModeId];\n            if (colorValue && typeof colorValue === \"object\") {\n                // Convert RGB values to hex\n                if (colorValue.r !== undefined && colorValue.g !== undefined && colorValue.b !== undefined) {\n                    return this.rgbToHex({\n                        r: colorValue.r,\n                        g: colorValue.g,\n                        b: colorValue.b\n                    });\n                }\n            }\n        } catch (error) {\n            console.log(`⚠️  Could not extract color from variable ${variable.name}`);\n        }\n        return null;\n    }\n    extractColorFromStyle(style, fileData) {\n        // Try to find the actual color value from the styles object in fileData\n        if (fileData.styles && fileData.styles[style.key]) {\n            const styleData = fileData.styles[style.key];\n            return this.extractColorValueFromStyleData(styleData);\n        }\n        // Fallback: try to infer from style name or return null\n        return null;\n    }\n    extractColorValueFromStyleData(styleData) {\n        try {\n            if (styleData.fills && styleData.fills.length > 0) {\n                const fill = styleData.fills[0];\n                if (fill.type === \"SOLID\" && fill.color) {\n                    return this.rgbToHex(fill.color);\n                }\n            }\n        } catch (error) {\n        // Silent fail for now\n        }\n        return null;\n    }\n    preserveDesignHierarchy(styleName) {\n        // Preserve the designer's hierarchical naming\n        return styleName.split(\"/\") // Handle \"Primary/Blue/500\" format\n        .map((part)=>part.trim()).map((part)=>this.sanitizeTokenName(part)).join(\"-\").toLowerCase();\n    }\n    traverseNodesForColors(node, colorCounts) {\n        if (!node) return;\n        // Extract fill colors\n        if (node.fills && Array.isArray(node.fills)) {\n            node.fills.forEach((fill)=>{\n                if (fill.type === \"SOLID\" && fill.color) {\n                    const hexColor = this.rgbToHex(fill.color);\n                    colorCounts[hexColor] = (colorCounts[hexColor] || 0) + 1;\n                }\n            });\n        }\n        // Extract stroke colors\n        if (node.strokes && Array.isArray(node.strokes)) {\n            node.strokes.forEach((stroke)=>{\n                if (stroke.type === \"SOLID\" && stroke.color) {\n                    const hexColor = this.rgbToHex(stroke.color);\n                    colorCounts[hexColor] = (colorCounts[hexColor] || 0) + 1;\n                }\n            });\n        }\n        // Recursively traverse children\n        if (node.children && Array.isArray(node.children)) {\n            node.children.forEach((child)=>{\n                this.traverseNodesForColors(child, colorCounts);\n            });\n        }\n    }\n    rgbToHex(color) {\n        const toHex = (c)=>{\n            const hex = Math.round(c * 255).toString(16);\n            return hex.length === 1 ? \"0\" + hex : hex;\n        };\n        return `#${toHex(color.r)}${toHex(color.g)}${toHex(color.b)}`.toUpperCase();\n    }\n    generateColorTokenName(color, index, count) {\n        // Try to generate semantic names based on color analysis\n        const colorAnalysis = this.analyzeColor(color);\n        if (colorAnalysis.name) {\n            return colorAnalysis.name;\n        }\n        return `color-${index + 1}`;\n    }\n    analyzeColor(hex) {\n        const color = hex.toLowerCase();\n        // Simple color categorization\n        if (color.includes(\"ff0000\") || color.includes(\"f00\") || color.startsWith(\"#e\") || color.startsWith(\"#d\")) {\n            return {\n                name: \"red\",\n                category: \"error\"\n            };\n        }\n        if (color.includes(\"00ff00\") || color.includes(\"0f0\") || color.includes(\"green\")) {\n            return {\n                name: \"green\",\n                category: \"success\"\n            };\n        }\n        if (color.includes(\"0000ff\") || color.includes(\"00f\") || color.includes(\"blue\")) {\n            return {\n                name: \"blue\",\n                category: \"primary\"\n            };\n        }\n        if (color.includes(\"ffffff\") || color === \"#fff\") {\n            return {\n                name: \"white\",\n                category: \"background\"\n            };\n        }\n        if (color.includes(\"000000\") || color === \"#000\") {\n            return {\n                name: \"black\",\n                category: \"text\"\n            };\n        }\n        return {\n            category: \"neutral\"\n        };\n    }\n    getFallbackColors() {\n        return {\n            primary: \"#007AFF\",\n            secondary: \"#5AC8FA\",\n            accent: \"#F43F5E\",\n            neutral: \"#8E8E93\"\n        };\n    }\n    extractTypographyFromStyles(fileData, stylesData) {\n        const typography = {};\n        // Extract typography from published text styles (primary source of truth)\n        const textStyles = stylesData.meta.styles.filter((style)=>style.style_type === \"TEXT\");\n        if (textStyles.length > 0) {\n            console.log(`📝 Found ${textStyles.length} published text styles`);\n            for (const style of textStyles){\n                const hierarchicalName = this.preserveDesignHierarchy(style.name);\n                const typographyProperties = this.extractTypographyFromStyle(style, fileData);\n                if (typographyProperties) {\n                    typography[hierarchicalName] = {\n                        ...typographyProperties,\n                        name: style.name,\n                        description: style.description || \"\"\n                    };\n                }\n            }\n        }\n        // Extract typography from Variables (if available)\n        // This is handled by the main extractTypographyFromVariables method now\n        // const variableTypography = this.extractTypographyFromVariables(fileData);\n        // Object.assign(typography, variableTypography);\n        console.log(`📊 Extracted ${Object.keys(typography).length} typography tokens from design system`);\n        return Object.keys(typography).length > 0 ? typography : this.getFallbackTypography();\n    }\n    extractTypographyFromVariables(variablesData, fileData, stylesData) {\n        const typography = {};\n        // Extract typography from Variables API (currently limited in Figma)\n        // Most typography variables are still handled via text styles\n        // Fallback to published text styles\n        console.log(\"\\uD83D\\uDCDD Typography variables not commonly available, using published text styles...\");\n        return this.extractTypographyFromStyles(fileData, stylesData);\n    }\n    extractTypographyFromStyle(style, fileData) {\n        // Try to find the actual typography properties from the styles object in fileData\n        if (fileData.styles && fileData.styles[style.key]) {\n            const styleData = fileData.styles[style.key];\n            return this.extractTypographyPropertiesFromStyleData(styleData);\n        }\n        return null;\n    }\n    extractTypographyPropertiesFromStyleData(styleData) {\n        try {\n            if (styleData.style) {\n                const textStyle = styleData.style;\n                return {\n                    fontSize: textStyle.fontSize || 16,\n                    fontWeight: textStyle.fontWeight || 400,\n                    lineHeight: textStyle.lineHeightPx ? textStyle.lineHeightPx / (textStyle.fontSize || 16) : textStyle.lineHeightPercent ? textStyle.lineHeightPercent / 100 : 1.4,\n                    fontFamily: textStyle.fontFamily || \"Inter\",\n                    letterSpacing: textStyle.letterSpacing || 0,\n                    textTransform: textStyle.textCase || \"none\"\n                };\n            }\n        } catch (error) {\n        // Silent fail for now\n        }\n        return null;\n    }\n    traverseNodesForTypography(node, textStyles) {\n        if (!node) return;\n        // Extract text properties from TEXT nodes\n        if (node.type === \"TEXT\" && node.style) {\n            const style = node.style;\n            const styleKey = this.generateTypographyKey(style);\n            if (!textStyles[styleKey]) {\n                textStyles[styleKey] = {\n                    fontSize: style.fontSize || 16,\n                    fontWeight: style.fontWeight || 400,\n                    lineHeight: style.lineHeightPx ? style.lineHeightPx / (style.fontSize || 16) : 1.4,\n                    fontFamily: style.fontFamily || \"Inter\",\n                    letterSpacing: style.letterSpacing || 0\n                };\n            }\n        }\n        // Recursively traverse children\n        if (node.children && Array.isArray(node.children)) {\n            node.children.forEach((child)=>{\n                this.traverseNodesForTypography(child, textStyles);\n            });\n        }\n    }\n    generateTypographyKey(style) {\n        const fontSize = style.fontSize || 16;\n        const fontWeight = style.fontWeight || 400;\n        // Generate semantic names based on size and weight\n        if (fontSize >= 32) return fontWeight >= 600 ? \"heading-xl\" : \"display-xl\";\n        if (fontSize >= 24) return fontWeight >= 600 ? \"heading-lg\" : \"display-lg\";\n        if (fontSize >= 20) return fontWeight >= 600 ? \"heading-md\" : \"display-md\";\n        if (fontSize >= 18) return fontWeight >= 600 ? \"heading-sm\" : \"text-lg\";\n        if (fontSize >= 16) return fontWeight >= 600 ? \"text-bold\" : \"text-base\";\n        if (fontSize >= 14) return \"text-sm\";\n        return \"text-xs\";\n    }\n    getFallbackTypography() {\n        return {\n            \"heading-xl\": {\n                fontSize: 32,\n                fontWeight: 700,\n                lineHeight: 1.2\n            },\n            \"heading-lg\": {\n                fontSize: 24,\n                fontWeight: 600,\n                lineHeight: 1.3\n            },\n            \"body\": {\n                fontSize: 16,\n                fontWeight: 400,\n                lineHeight: 1.5\n            }\n        };\n    }\n    extractSpacing(fileData) {\n        const spacing = {};\n        const spacingCounts = {};\n        // Extract spacing from Auto Layout nodes\n        this.traverseNodesForSpacing(fileData.document, spacingCounts);\n        // Convert to tokens with semantic names\n        Object.entries(spacingCounts).sort(([, a], [, b])=>b - a).slice(0, 15).forEach(([space, count], index)=>{\n            const tokenName = this.generateSpacingName(Number(space));\n            spacing[tokenName] = Number(space);\n        });\n        console.log(`📊 Found ${Object.keys(spacing).length} spacing tokens`);\n        return Object.keys(spacing).length > 0 ? spacing : this.getFallbackSpacing();\n    }\n    traverseNodesForSpacing(node, spacingCounts) {\n        if (!node) return;\n        // Extract Auto Layout spacing\n        if (node.layoutMode && node.itemSpacing && typeof node.itemSpacing === \"number\") {\n            spacingCounts[node.itemSpacing] = (spacingCounts[node.itemSpacing] || 0) + 1;\n        }\n        // Extract padding from Auto Layout\n        if (node.paddingLeft && typeof node.paddingLeft === \"number\") {\n            spacingCounts[node.paddingLeft] = (spacingCounts[node.paddingLeft] || 0) + 1;\n        }\n        if (node.paddingTop && typeof node.paddingTop === \"number\") {\n            spacingCounts[node.paddingTop] = (spacingCounts[node.paddingTop] || 0) + 1;\n        }\n        // Recursively traverse children\n        if (node.children && Array.isArray(node.children)) {\n            node.children.forEach((child)=>{\n                this.traverseNodesForSpacing(child, spacingCounts);\n            });\n        }\n    }\n    generateSpacingName(spacing) {\n        if (spacing === 0) return \"none\";\n        if (spacing <= 2) return \"xs\";\n        if (spacing <= 4) return \"sm\";\n        if (spacing <= 8) return \"md\";\n        if (spacing <= 12) return \"lg\";\n        if (spacing <= 16) return \"xl\";\n        if (spacing <= 24) return \"2xl\";\n        if (spacing <= 32) return \"3xl\";\n        if (spacing <= 48) return \"4xl\";\n        return \"5xl\";\n    }\n    getFallbackSpacing() {\n        return {\n            xs: 4,\n            sm: 8,\n            md: 16,\n            lg: 24,\n            xl: 32\n        };\n    }\n    extractEffectsFromStyles(fileData, stylesData) {\n        const effects = {};\n        // Extract effects from published effect styles (primary source of truth)\n        const effectStyles = stylesData.meta.styles.filter((style)=>style.style_type === \"EFFECT\");\n        if (effectStyles.length > 0) {\n            console.log(`✨ Found ${effectStyles.length} published effect styles`);\n            for (const style of effectStyles){\n                const hierarchicalName = this.preserveDesignHierarchy(style.name);\n                const effectProperties = this.extractEffectFromStyle(style, fileData);\n                if (effectProperties) {\n                    effects[hierarchicalName] = {\n                        ...effectProperties,\n                        name: style.name,\n                        description: style.description || \"\"\n                    };\n                }\n            }\n        }\n        // Extract effects from Variables (if available)\n        const variableEffects = this.extractEffectsFromVariables(fileData);\n        Object.assign(effects, variableEffects);\n        console.log(`📊 Extracted ${Object.keys(effects).length} effect tokens from design system`);\n        return Object.keys(effects).length > 0 ? effects : this.getFallbackEffects();\n    }\n    extractEffectsFromVariables(fileData) {\n        const effects = {};\n        // Check if file has effect variables\n        if (fileData.styles && typeof fileData.styles === \"object\") {\n            Object.entries(fileData.styles).forEach(([styleId, styleData])=>{\n                if (styleData.styleType === \"EFFECT\" && styleData.name) {\n                    const hierarchicalName = this.preserveDesignHierarchy(styleData.name);\n                    const effectProperties = this.extractEffectPropertiesFromStyleData(styleData);\n                    if (effectProperties) {\n                        effects[hierarchicalName] = effectProperties;\n                    }\n                }\n            });\n        }\n        return effects;\n    }\n    extractEffectFromStyle(style, fileData) {\n        // Try to find the actual effect properties from the styles object in fileData\n        if (fileData.styles && fileData.styles[style.key]) {\n            const styleData = fileData.styles[style.key];\n            return this.extractEffectPropertiesFromStyleData(styleData);\n        }\n        return null;\n    }\n    extractEffectPropertiesFromStyleData(styleData) {\n        try {\n            if (styleData.effects && styleData.effects.length > 0) {\n                const effect = styleData.effects[0]; // Take the first effect\n                if (effect.type === \"DROP_SHADOW\" || effect.type === \"INNER_SHADOW\") {\n                    return {\n                        type: effect.type.toLowerCase().replace(\"_\", \"\"),\n                        x: effect.offset?.x || 0,\n                        y: effect.offset?.y || 0,\n                        blur: effect.radius || 0,\n                        spread: effect.spread || 0,\n                        color: effect.color ? this.rgbaToString(effect.color) : \"rgba(0, 0, 0, 0.1)\"\n                    };\n                }\n            }\n        } catch (error) {\n        // Silent fail for now\n        }\n        return null;\n    }\n    traverseNodesForEffects(node, effectsFound) {\n        if (!node) return;\n        // Extract effects\n        if (node.effects && Array.isArray(node.effects)) {\n            node.effects.forEach((effect)=>{\n                if (effect.type === \"DROP_SHADOW\" || effect.type === \"INNER_SHADOW\") {\n                    effectsFound.push({\n                        type: effect.type.toLowerCase().replace(\"_\", \"\"),\n                        x: effect.offset?.x || 0,\n                        y: effect.offset?.y || 0,\n                        blur: effect.radius || 0,\n                        spread: effect.spread || 0,\n                        color: effect.color ? this.rgbaToString(effect.color) : \"rgba(0, 0, 0, 0.1)\"\n                    });\n                }\n            });\n        }\n        // Recursively traverse children\n        if (node.children && Array.isArray(node.children)) {\n            node.children.forEach((child)=>{\n                this.traverseNodesForEffects(child, effectsFound);\n            });\n        }\n    }\n    generateEffectName(effect, index) {\n        const blur = effect.blur || 0;\n        if (blur <= 2) return `shadow-xs`;\n        if (blur <= 4) return `shadow-sm`;\n        if (blur <= 8) return `shadow-md`;\n        if (blur <= 16) return `shadow-lg`;\n        return `shadow-xl`;\n    }\n    rgbaToString(color) {\n        const r = Math.round(color.r * 255);\n        const g = Math.round(color.g * 255);\n        const b = Math.round(color.b * 255);\n        const a = color.a !== undefined ? color.a : 1;\n        return `rgba(${r}, ${g}, ${b}, ${a})`;\n    }\n    getFallbackEffects() {\n        return {\n            \"shadow-sm\": {\n                type: \"dropShadow\",\n                x: 0,\n                y: 1,\n                blur: 3,\n                spread: 0,\n                color: \"rgba(0, 0, 0, 0.1)\"\n            },\n            \"shadow-lg\": {\n                type: \"dropShadow\",\n                x: 0,\n                y: 4,\n                blur: 6,\n                spread: -1,\n                color: \"rgba(0, 0, 0, 0.1)\"\n            }\n        };\n    }\n    extractBorderRadius(fileData) {\n        const borderRadius = {};\n        const radiusCounts = {};\n        // Extract border radius from document nodes\n        this.traverseNodesForBorderRadius(fileData.document, radiusCounts);\n        // Convert to tokens\n        Object.entries(radiusCounts).sort(([, a], [, b])=>b - a).slice(0, 10).forEach(([radius, count], index)=>{\n            const tokenName = this.generateBorderRadiusName(Number(radius));\n            borderRadius[tokenName] = Number(radius);\n        });\n        console.log(`📊 Found ${Object.keys(borderRadius).length} border radius tokens`);\n        return Object.keys(borderRadius).length > 0 ? borderRadius : this.getFallbackBorderRadius();\n    }\n    traverseNodesForBorderRadius(node, radiusCounts) {\n        if (!node) return;\n        // Extract corner radius from rectangles and other shapes\n        if (node.type === \"RECTANGLE\" || node.type === \"FRAME\") {\n            if (node.cornerRadius && typeof node.cornerRadius === \"number\") {\n                radiusCounts[node.cornerRadius] = (radiusCounts[node.cornerRadius] || 0) + 1;\n            }\n            // Handle individual corner radius\n            if (node.rectangleCornerRadii && Array.isArray(node.rectangleCornerRadii)) {\n                node.rectangleCornerRadii.forEach((radius)=>{\n                    if (typeof radius === \"number\") {\n                        radiusCounts[radius] = (radiusCounts[radius] || 0) + 1;\n                    }\n                });\n            }\n        }\n        // Recursively traverse children\n        if (node.children && Array.isArray(node.children)) {\n            node.children.forEach((child)=>{\n                this.traverseNodesForBorderRadius(child, radiusCounts);\n            });\n        }\n    }\n    generateBorderRadiusName(radius) {\n        if (radius === 0) return \"none\";\n        if (radius <= 2) return \"sm\";\n        if (radius <= 4) return \"md\";\n        if (radius <= 8) return \"lg\";\n        if (radius <= 12) return \"xl\";\n        if (radius <= 16) return \"2xl\";\n        if (radius >= 9999 || radius >= 1000) return \"full\";\n        return \"3xl\";\n    }\n    getFallbackBorderRadius() {\n        return {\n            none: 0,\n            sm: 2,\n            md: 4,\n            lg: 8,\n            xl: 12,\n            full: 9999\n        };\n    }\n    extractStrokeWeights(fileData) {\n        const strokeWeights = {};\n        const weightCounts = {};\n        // Extract stroke weights from document nodes\n        this.traverseNodesForStrokes(fileData.document, weightCounts);\n        // Convert to tokens\n        Object.entries(weightCounts).sort(([, a], [, b])=>b - a).slice(0, 10).forEach(([weight, count], index)=>{\n            const tokenName = this.generateStrokeWeightName(Number(weight));\n            strokeWeights[tokenName] = Number(weight);\n        });\n        console.log(`📊 Found ${Object.keys(strokeWeights).length} stroke weight tokens`);\n        return Object.keys(strokeWeights).length > 0 ? strokeWeights : this.getFallbackStrokeWeights();\n    }\n    traverseNodesForStrokes(node, weightCounts) {\n        if (!node) return;\n        // Extract stroke weights\n        if (node.strokeWeight && typeof node.strokeWeight === \"number\") {\n            weightCounts[node.strokeWeight] = (weightCounts[node.strokeWeight] || 0) + 1;\n        }\n        // Recursively traverse children\n        if (node.children && Array.isArray(node.children)) {\n            node.children.forEach((child)=>{\n                this.traverseNodesForStrokes(child, weightCounts);\n            });\n        }\n    }\n    generateStrokeWeightName(weight) {\n        if (weight <= 1) return \"thin\";\n        if (weight <= 2) return \"normal\";\n        if (weight <= 4) return \"medium\";\n        if (weight <= 6) return \"thick\";\n        return \"extra-thick\";\n    }\n    getFallbackStrokeWeights() {\n        return {\n            thin: 1,\n            normal: 2,\n            thick: 4\n        };\n    }\n    extractSpacingFromVariables(variablesData) {\n        const spacing = {};\n        // Extract spacing from Variables API\n        if (variablesData.meta.variables) {\n            Object.entries(variablesData.meta.variables).forEach(([variableId, variable])=>{\n                if (variable.resolvedType === \"FLOAT\" && variable.name.toLowerCase().includes(\"spacing\")) {\n                    const hierarchicalName = this.preserveDesignHierarchy(variable.name);\n                    const spacingValue = this.extractNumberFromVariable(variable, variablesData);\n                    if (spacingValue !== null) {\n                        spacing[hierarchicalName] = spacingValue;\n                    }\n                }\n            });\n        }\n        console.log(`📊 Extracted ${Object.keys(spacing).length} spacing tokens from variables`);\n        return Object.keys(spacing).length > 0 ? spacing : this.getFallbackSpacing();\n    }\n    extractBorderRadiusFromVariables(variablesData) {\n        const borderRadius = {};\n        // Extract border radius from Variables API\n        if (variablesData.meta.variables) {\n            Object.entries(variablesData.meta.variables).forEach(([variableId, variable])=>{\n                if (variable.resolvedType === \"FLOAT\" && (variable.name.toLowerCase().includes(\"radius\") || variable.name.toLowerCase().includes(\"border\"))) {\n                    const hierarchicalName = this.preserveDesignHierarchy(variable.name);\n                    const radiusValue = this.extractNumberFromVariable(variable, variablesData);\n                    if (radiusValue !== null) {\n                        borderRadius[hierarchicalName] = radiusValue;\n                    }\n                }\n            });\n        }\n        console.log(`📊 Extracted ${Object.keys(borderRadius).length} border radius tokens from variables`);\n        return Object.keys(borderRadius).length > 0 ? borderRadius : this.getFallbackBorderRadius();\n    }\n    extractStrokeWeightsFromVariables(variablesData) {\n        const strokeWeights = {};\n        // Extract stroke weights from Variables API\n        if (variablesData.meta.variables) {\n            Object.entries(variablesData.meta.variables).forEach(([variableId, variable])=>{\n                if (variable.resolvedType === \"FLOAT\" && (variable.name.toLowerCase().includes(\"stroke\") || variable.name.toLowerCase().includes(\"weight\"))) {\n                    const hierarchicalName = this.preserveDesignHierarchy(variable.name);\n                    const strokeValue = this.extractNumberFromVariable(variable, variablesData);\n                    if (strokeValue !== null) {\n                        strokeWeights[hierarchicalName] = strokeValue;\n                    }\n                }\n            });\n        }\n        console.log(`📊 Extracted ${Object.keys(strokeWeights).length} stroke weight tokens from variables`);\n        return Object.keys(strokeWeights).length > 0 ? strokeWeights : this.getFallbackStrokeWeights();\n    }\n    extractNumberFromVariable(variable, variablesData) {\n        try {\n            const collection = variablesData.meta.variableCollections[variable.variableCollectionId];\n            if (!collection) return null;\n            const defaultModeId = collection.defaultModeId;\n            const value = variable.valuesByMode[defaultModeId];\n            if (typeof value === \"number\") {\n                return value;\n            }\n        } catch (error) {\n            console.log(`⚠️  Could not extract number from variable ${variable.name}`);\n        }\n        return null;\n    }\n    // Utility methods\n    sanitizeTokenName(name) {\n        return name.toLowerCase().replace(/[^a-z0-9]/g, \"-\").replace(/-+/g, \"-\").replace(/^-|-$/g, \"\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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U1YsSUFBSSxDQUFDLENBQUM7UUFDM0U7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxrQkFBa0I7SUFDVm9DLGtCQUFrQnBDLElBQVksRUFBVTtRQUM5QyxPQUFPQSxLQUNKc0MsV0FBVyxHQUNYa0YsT0FBTyxDQUFDLGNBQWMsS0FDdEJBLE9BQU8sQ0FBQyxPQUFPLEtBQ2ZBLE9BQU8sQ0FBQyxVQUFVO0lBQ3ZCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maWdtYS1kZXNpZ24tZXh0cmFjdG9yLy4vc3JjL3Byb2Nlc3NvcnMvdG9rZW5QYXJzZXIudHM/M2YxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGaWdtYUZpbGVSZXNwb25zZSwgRmlnbWFTdHlsZXNSZXNwb25zZSwgRmlnbWFWYXJpYWJsZXNSZXNwb25zZSB9IGZyb20gJy4uL3NlcnZpY2VzL2ZpZ21hLWFwaSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVzaWduVG9rZW5zIHtcbiAgY29sb3I6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIHR5cG9ncmFwaHk6IHsgW2tleTogc3RyaW5nXTogYW55IH07XG4gIHNwYWNpbmc6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH07XG4gIGVmZmVjdHM6IHsgW2tleTogc3RyaW5nXTogYW55IH07XG4gIGJvcmRlclJhZGl1czogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfTtcbiAgc3Ryb2tlV2VpZ2h0OiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9O1xufVxuXG5leHBvcnQgY2xhc3MgVG9rZW5QYXJzZXIge1xuICAgICAgcGFyc2VUb2tlbnMoZmlsZURhdGE6IEZpZ21hRmlsZVJlc3BvbnNlLCBzdHlsZXNEYXRhOiBGaWdtYVN0eWxlc1Jlc3BvbnNlLCB2YXJpYWJsZXNEYXRhOiBGaWdtYVZhcmlhYmxlc1Jlc3BvbnNlKTogRGVzaWduVG9rZW5zIHtcbiAgICBjb25zb2xlLmxvZygn8J+OqCBFeHRyYWN0aW5nIGRlc2lnbiB0b2tlbnMgZnJvbSBwdWJsaXNoZWQgc3R5bGVzIGFuZCB2YXJpYWJsZXMuLi4nKTtcblxuICAgIGNvbnN0IHRva2VuczogRGVzaWduVG9rZW5zID0ge1xuICAgICAgY29sb3I6IHRoaXMuZXh0cmFjdENvbG9yc0Zyb21WYXJpYWJsZXModmFyaWFibGVzRGF0YSwgZmlsZURhdGEsIHN0eWxlc0RhdGEpLFxuICAgICAgdHlwb2dyYXBoeTogdGhpcy5leHRyYWN0VHlwb2dyYXBoeUZyb21WYXJpYWJsZXModmFyaWFibGVzRGF0YSwgZmlsZURhdGEsIHN0eWxlc0RhdGEpLFxuICAgICAgc3BhY2luZzogdGhpcy5leHRyYWN0U3BhY2luZ0Zyb21WYXJpYWJsZXModmFyaWFibGVzRGF0YSksXG4gICAgICBlZmZlY3RzOiB0aGlzLmV4dHJhY3RFZmZlY3RzRnJvbVN0eWxlcyhmaWxlRGF0YSwgc3R5bGVzRGF0YSksXG4gICAgICBib3JkZXJSYWRpdXM6IHRoaXMuZXh0cmFjdEJvcmRlclJhZGl1c0Zyb21WYXJpYWJsZXModmFyaWFibGVzRGF0YSksXG4gICAgICBzdHJva2VXZWlnaHQ6IHRoaXMuZXh0cmFjdFN0cm9rZVdlaWdodHNGcm9tVmFyaWFibGVzKHZhcmlhYmxlc0RhdGEpXG4gICAgfTtcblxuICAgIGNvbnNvbGUubG9nKCfinIUgRGVzaWduIHN5c3RlbSBleHRyYWN0aW9uIGNvbXBsZXRlJyk7XG4gICAgcmV0dXJuIHRva2VucztcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdENvbG9yc0Zyb21TdHlsZXMoZmlsZURhdGE6IEZpZ21hRmlsZVJlc3BvbnNlLCBzdHlsZXNEYXRhOiBGaWdtYVN0eWxlc1Jlc3BvbnNlKTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSB7XG4gICAgY29uc3QgY29sb3JzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG5cbiAgICAvLyBFeHRyYWN0IGNvbG9ycyBmcm9tIHB1Ymxpc2hlZCBmaWxsIHN0eWxlcyAocHJpbWFyeSBzb3VyY2Ugb2YgdHJ1dGgpXG4gICAgY29uc3QgZmlsbFN0eWxlcyA9IHN0eWxlc0RhdGEubWV0YS5zdHlsZXMuZmlsdGVyKHN0eWxlID0+IHN0eWxlLnN0eWxlX3R5cGUgPT09ICdGSUxMJyk7XG5cbiAgICBpZiAoZmlsbFN0eWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OqCBGb3VuZCAke2ZpbGxTdHlsZXMubGVuZ3RofSBwdWJsaXNoZWQgY29sb3Igc3R5bGVzYCk7XG5cbiAgICAgIGZvciAoY29uc3Qgc3R5bGUgb2YgZmlsbFN0eWxlcykge1xuICAgICAgICBjb25zdCBoaWVyYXJjaGljYWxOYW1lID0gdGhpcy5wcmVzZXJ2ZURlc2lnbkhpZXJhcmNoeShzdHlsZS5uYW1lKTtcbiAgICAgICAgY29uc3QgY29sb3JWYWx1ZSA9IHRoaXMuZXh0cmFjdENvbG9yRnJvbVN0eWxlKHN0eWxlLCBmaWxlRGF0YSk7XG5cbiAgICAgICAgaWYgKGNvbG9yVmFsdWUpIHtcbiAgICAgICAgICBjb2xvcnNbaGllcmFyY2hpY2FsTmFtZV0gPSBjb2xvclZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCBjb2xvcnMgZnJvbSBWYXJpYWJsZXMgKGlmIGF2YWlsYWJsZSBpbiBmaWxlKVxuICAgIC8vIFRoaXMgaXMgaGFuZGxlZCBieSB0aGUgbWFpbiBleHRyYWN0Q29sb3JzRnJvbVZhcmlhYmxlcyBtZXRob2Qgbm93XG4gICAgLy8gY29uc3QgdmFyaWFibGVDb2xvcnMgPSB0aGlzLmV4dHJhY3RDb2xvcnNGcm9tVmFyaWFibGVzKGZpbGVEYXRhKTtcbiAgICAvLyBPYmplY3QuYXNzaWduKGNvbG9ycywgdmFyaWFibGVDb2xvcnMpO1xuXG4gICAgY29uc29sZS5sb2coYPCfk4ogRXh0cmFjdGVkICR7T2JqZWN0LmtleXMoY29sb3JzKS5sZW5ndGh9IGNvbG9yIHRva2VucyBmcm9tIGRlc2lnbiBzeXN0ZW1gKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoY29sb3JzKS5sZW5ndGggPiAwID8gY29sb3JzIDogdGhpcy5nZXRGYWxsYmFja0NvbG9ycygpO1xuICB9XG5cbiAgICBwcml2YXRlIGV4dHJhY3RDb2xvcnNGcm9tVmFyaWFibGVzKHZhcmlhYmxlc0RhdGE6IEZpZ21hVmFyaWFibGVzUmVzcG9uc2UsIGZpbGVEYXRhOiBGaWdtYUZpbGVSZXNwb25zZSwgc3R5bGVzRGF0YTogRmlnbWFTdHlsZXNSZXNwb25zZSk6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0ge1xuICAgIGNvbnN0IGNvbG9yczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuXG4gICAgLy8gRXh0cmFjdCBjb2xvcnMgZnJvbSBWYXJpYWJsZXMgQVBJIChwcmltYXJ5IHNvdXJjZSBvZiB0cnV0aClcbiAgICBpZiAodmFyaWFibGVzRGF0YS5tZXRhLnZhcmlhYmxlcykge1xuICAgICAgY29uc29sZS5sb2coYPCfjqggUHJvY2Vzc2luZyAke09iamVjdC5rZXlzKHZhcmlhYmxlc0RhdGEubWV0YS52YXJpYWJsZXMpLmxlbmd0aH0gdmFyaWFibGVzIGZvciBjb2xvcnMuLi5gKTtcblxuICAgICAgT2JqZWN0LmVudHJpZXModmFyaWFibGVzRGF0YS5tZXRhLnZhcmlhYmxlcykuZm9yRWFjaCgoW3ZhcmlhYmxlSWQsIHZhcmlhYmxlXSkgPT4ge1xuICAgICAgICBpZiAodmFyaWFibGUucmVzb2x2ZWRUeXBlID09PSAnQ09MT1InKSB7XG4gICAgICAgICAgY29uc3QgaGllcmFyY2hpY2FsTmFtZSA9IHRoaXMucHJlc2VydmVEZXNpZ25IaWVyYXJjaHkodmFyaWFibGUubmFtZSk7XG4gICAgICAgICAgY29uc3QgY29sb3JWYWx1ZSA9IHRoaXMuZXh0cmFjdENvbG9yRnJvbVZhcmlhYmxlKHZhcmlhYmxlLCB2YXJpYWJsZXNEYXRhKTtcblxuICAgICAgICAgIGlmIChjb2xvclZhbHVlKSB7XG4gICAgICAgICAgICBjb2xvcnNbaGllcmFyY2hpY2FsTmFtZV0gPSBjb2xvclZhbHVlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKckyBGb3VuZCBjb2xvciB2YXJpYWJsZTogJHt2YXJpYWJsZS5uYW1lfSA9ICR7Y29sb3JWYWx1ZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIHRvIHB1Ymxpc2hlZCBzdHlsZXMgaWYgbm8gdmFyaWFibGVzIGZvdW5kXG4gICAgaWYgKE9iamVjdC5rZXlzKGNvbG9ycykubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+TjiBObyBjb2xvciB2YXJpYWJsZXMgZm91bmQsIGZhbGxpbmcgYmFjayB0byBwdWJsaXNoZWQgc3R5bGVzLi4uJyk7XG4gICAgICBjb25zdCBmYWxsYmFja0NvbG9ycyA9IHRoaXMuZXh0cmFjdENvbG9yc0Zyb21TdHlsZXMoZmlsZURhdGEsIHN0eWxlc0RhdGEpO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGZhbGxiYWNrQ29sb3JzKS5sZW5ndGggPiAwID8gZmFsbGJhY2tDb2xvcnMgOiB0aGlzLmdldEZhbGxiYWNrQ29sb3JzKCk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYPCfk4ogRXh0cmFjdGVkICR7T2JqZWN0LmtleXMoY29sb3JzKS5sZW5ndGh9IGNvbG9yIHRva2VucyBmcm9tIHZhcmlhYmxlc2ApO1xuICAgIHJldHVybiBjb2xvcnM7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RDb2xvckZyb21WYXJpYWJsZSh2YXJpYWJsZTogYW55LCB2YXJpYWJsZXNEYXRhOiBGaWdtYVZhcmlhYmxlc1Jlc3BvbnNlKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCB0aGUgZGVmYXVsdCBtb2RlIGZyb20gdGhlIHZhcmlhYmxlIGNvbGxlY3Rpb25cbiAgICAgIGNvbnN0IGNvbGxlY3Rpb24gPSB2YXJpYWJsZXNEYXRhLm1ldGEudmFyaWFibGVDb2xsZWN0aW9uc1t2YXJpYWJsZS52YXJpYWJsZUNvbGxlY3Rpb25JZF07XG4gICAgICBpZiAoIWNvbGxlY3Rpb24pIHJldHVybiBudWxsO1xuXG4gICAgICBjb25zdCBkZWZhdWx0TW9kZUlkID0gY29sbGVjdGlvbi5kZWZhdWx0TW9kZUlkO1xuICAgICAgY29uc3QgY29sb3JWYWx1ZSA9IHZhcmlhYmxlLnZhbHVlc0J5TW9kZVtkZWZhdWx0TW9kZUlkXTtcblxuICAgICAgaWYgKGNvbG9yVmFsdWUgJiYgdHlwZW9mIGNvbG9yVmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIENvbnZlcnQgUkdCIHZhbHVlcyB0byBoZXhcbiAgICAgICAgaWYgKGNvbG9yVmFsdWUuciAhPT0gdW5kZWZpbmVkICYmIGNvbG9yVmFsdWUuZyAhPT0gdW5kZWZpbmVkICYmIGNvbG9yVmFsdWUuYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmdiVG9IZXgoe1xuICAgICAgICAgICAgcjogY29sb3JWYWx1ZS5yLFxuICAgICAgICAgICAgZzogY29sb3JWYWx1ZS5nLFxuICAgICAgICAgICAgYjogY29sb3JWYWx1ZS5iXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coYOKaoO+4jyAgQ291bGQgbm90IGV4dHJhY3QgY29sb3IgZnJvbSB2YXJpYWJsZSAke3ZhcmlhYmxlLm5hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0Q29sb3JGcm9tU3R5bGUoc3R5bGU6IGFueSwgZmlsZURhdGE6IEZpZ21hRmlsZVJlc3BvbnNlKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgLy8gVHJ5IHRvIGZpbmQgdGhlIGFjdHVhbCBjb2xvciB2YWx1ZSBmcm9tIHRoZSBzdHlsZXMgb2JqZWN0IGluIGZpbGVEYXRhXG4gICAgaWYgKGZpbGVEYXRhLnN0eWxlcyAmJiBmaWxlRGF0YS5zdHlsZXNbc3R5bGUua2V5XSkge1xuICAgICAgY29uc3Qgc3R5bGVEYXRhID0gZmlsZURhdGEuc3R5bGVzW3N0eWxlLmtleV07XG4gICAgICByZXR1cm4gdGhpcy5leHRyYWN0Q29sb3JWYWx1ZUZyb21TdHlsZURhdGEoc3R5bGVEYXRhKTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjazogdHJ5IHRvIGluZmVyIGZyb20gc3R5bGUgbmFtZSBvciByZXR1cm4gbnVsbFxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0Q29sb3JWYWx1ZUZyb21TdHlsZURhdGEoc3R5bGVEYXRhOiBhbnkpOiBzdHJpbmcgfCBudWxsIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHN0eWxlRGF0YS5maWxscyAmJiBzdHlsZURhdGEuZmlsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBmaWxsID0gc3R5bGVEYXRhLmZpbGxzWzBdO1xuICAgICAgICBpZiAoZmlsbC50eXBlID09PSAnU09MSUQnICYmIGZpbGwuY29sb3IpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZ2JUb0hleChmaWxsLmNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBTaWxlbnQgZmFpbCBmb3Igbm93XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBwcmVzZXJ2ZURlc2lnbkhpZXJhcmNoeShzdHlsZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgLy8gUHJlc2VydmUgdGhlIGRlc2lnbmVyJ3MgaGllcmFyY2hpY2FsIG5hbWluZ1xuICAgIHJldHVybiBzdHlsZU5hbWVcbiAgICAgIC5zcGxpdCgnLycpICAvLyBIYW5kbGUgXCJQcmltYXJ5L0JsdWUvNTAwXCIgZm9ybWF0XG4gICAgICAubWFwKHBhcnQgPT4gcGFydC50cmltKCkpXG4gICAgICAubWFwKHBhcnQgPT4gdGhpcy5zYW5pdGl6ZVRva2VuTmFtZShwYXJ0KSlcbiAgICAgIC5qb2luKCctJylcbiAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSB0cmF2ZXJzZU5vZGVzRm9yQ29sb3JzKG5vZGU6IGFueSwgY29sb3JDb3VudHM6IHsgW2NvbG9yOiBzdHJpbmddOiBudW1iZXIgfSkge1xuICAgIGlmICghbm9kZSkgcmV0dXJuO1xuXG4gICAgLy8gRXh0cmFjdCBmaWxsIGNvbG9yc1xuICAgIGlmIChub2RlLmZpbGxzICYmIEFycmF5LmlzQXJyYXkobm9kZS5maWxscykpIHtcbiAgICAgIG5vZGUuZmlsbHMuZm9yRWFjaCgoZmlsbDogYW55KSA9PiB7XG4gICAgICAgIGlmIChmaWxsLnR5cGUgPT09ICdTT0xJRCcgJiYgZmlsbC5jb2xvcikge1xuICAgICAgICAgIGNvbnN0IGhleENvbG9yID0gdGhpcy5yZ2JUb0hleChmaWxsLmNvbG9yKTtcbiAgICAgICAgICBjb2xvckNvdW50c1toZXhDb2xvcl0gPSAoY29sb3JDb3VudHNbaGV4Q29sb3JdIHx8IDApICsgMTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCBzdHJva2UgY29sb3JzXG4gICAgaWYgKG5vZGUuc3Ryb2tlcyAmJiBBcnJheS5pc0FycmF5KG5vZGUuc3Ryb2tlcykpIHtcbiAgICAgIG5vZGUuc3Ryb2tlcy5mb3JFYWNoKChzdHJva2U6IGFueSkgPT4ge1xuICAgICAgICBpZiAoc3Ryb2tlLnR5cGUgPT09ICdTT0xJRCcgJiYgc3Ryb2tlLmNvbG9yKSB7XG4gICAgICAgICAgY29uc3QgaGV4Q29sb3IgPSB0aGlzLnJnYlRvSGV4KHN0cm9rZS5jb2xvcik7XG4gICAgICAgICAgY29sb3JDb3VudHNbaGV4Q29sb3JdID0gKGNvbG9yQ291bnRzW2hleENvbG9yXSB8fCAwKSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGNoaWxkcmVuXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4gJiYgQXJyYXkuaXNBcnJheShub2RlLmNoaWxkcmVuKSkge1xuICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZDogYW55KSA9PiB7XG4gICAgICAgIHRoaXMudHJhdmVyc2VOb2Rlc0ZvckNvbG9ycyhjaGlsZCwgY29sb3JDb3VudHMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZ2JUb0hleChjb2xvcjogeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyIH0pOiBzdHJpbmcge1xuICAgIGNvbnN0IHRvSGV4ID0gKGM6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3QgaGV4ID0gTWF0aC5yb3VuZChjICogMjU1KS50b1N0cmluZygxNik7XG4gICAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyArIGhleCA6IGhleDtcbiAgICB9O1xuICAgIHJldHVybiBgIyR7dG9IZXgoY29sb3Iucil9JHt0b0hleChjb2xvci5nKX0ke3RvSGV4KGNvbG9yLmIpfWAudG9VcHBlckNhc2UoKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVDb2xvclRva2VuTmFtZShjb2xvcjogc3RyaW5nLCBpbmRleDogbnVtYmVyLCBjb3VudDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICAvLyBUcnkgdG8gZ2VuZXJhdGUgc2VtYW50aWMgbmFtZXMgYmFzZWQgb24gY29sb3IgYW5hbHlzaXNcbiAgICBjb25zdCBjb2xvckFuYWx5c2lzID0gdGhpcy5hbmFseXplQ29sb3IoY29sb3IpO1xuICAgIGlmIChjb2xvckFuYWx5c2lzLm5hbWUpIHtcbiAgICAgIHJldHVybiBjb2xvckFuYWx5c2lzLm5hbWU7XG4gICAgfVxuICAgIHJldHVybiBgY29sb3ItJHtpbmRleCArIDF9YDtcbiAgfVxuXG4gIHByaXZhdGUgYW5hbHl6ZUNvbG9yKGhleDogc3RyaW5nKTogeyBuYW1lPzogc3RyaW5nOyBjYXRlZ29yeTogc3RyaW5nIH0ge1xuICAgIGNvbnN0IGNvbG9yID0gaGV4LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBTaW1wbGUgY29sb3IgY2F0ZWdvcml6YXRpb25cbiAgICBpZiAoY29sb3IuaW5jbHVkZXMoJ2ZmMDAwMCcpIHx8IGNvbG9yLmluY2x1ZGVzKCdmMDAnKSB8fCBjb2xvci5zdGFydHNXaXRoKCcjZScpIHx8IGNvbG9yLnN0YXJ0c1dpdGgoJyNkJykpIHtcbiAgICAgIHJldHVybiB7IG5hbWU6ICdyZWQnLCBjYXRlZ29yeTogJ2Vycm9yJyB9O1xuICAgIH1cbiAgICBpZiAoY29sb3IuaW5jbHVkZXMoJzAwZmYwMCcpIHx8IGNvbG9yLmluY2x1ZGVzKCcwZjAnKSB8fCBjb2xvci5pbmNsdWRlcygnZ3JlZW4nKSkge1xuICAgICAgcmV0dXJuIHsgbmFtZTogJ2dyZWVuJywgY2F0ZWdvcnk6ICdzdWNjZXNzJyB9O1xuICAgIH1cbiAgICBpZiAoY29sb3IuaW5jbHVkZXMoJzAwMDBmZicpIHx8IGNvbG9yLmluY2x1ZGVzKCcwMGYnKSB8fCBjb2xvci5pbmNsdWRlcygnYmx1ZScpKSB7XG4gICAgICByZXR1cm4geyBuYW1lOiAnYmx1ZScsIGNhdGVnb3J5OiAncHJpbWFyeScgfTtcbiAgICB9XG4gICAgaWYgKGNvbG9yLmluY2x1ZGVzKCdmZmZmZmYnKSB8fCBjb2xvciA9PT0gJyNmZmYnKSB7XG4gICAgICByZXR1cm4geyBuYW1lOiAnd2hpdGUnLCBjYXRlZ29yeTogJ2JhY2tncm91bmQnIH07XG4gICAgfVxuICAgIGlmIChjb2xvci5pbmNsdWRlcygnMDAwMDAwJykgfHwgY29sb3IgPT09ICcjMDAwJykge1xuICAgICAgcmV0dXJuIHsgbmFtZTogJ2JsYWNrJywgY2F0ZWdvcnk6ICd0ZXh0JyB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IGNhdGVnb3J5OiAnbmV1dHJhbCcgfTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RmFsbGJhY2tDb2xvcnMoKTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByaW1hcnk6ICcjMDA3QUZGJyxcbiAgICAgIHNlY29uZGFyeTogJyM1QUM4RkEnLFxuICAgICAgYWNjZW50OiAnI0Y0M0Y1RScsXG4gICAgICBuZXV0cmFsOiAnIzhFOEU5MydcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0VHlwb2dyYXBoeUZyb21TdHlsZXMoZmlsZURhdGE6IEZpZ21hRmlsZVJlc3BvbnNlLCBzdHlsZXNEYXRhOiBGaWdtYVN0eWxlc1Jlc3BvbnNlKTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB7XG4gICAgY29uc3QgdHlwb2dyYXBoeTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuXG4gICAgLy8gRXh0cmFjdCB0eXBvZ3JhcGh5IGZyb20gcHVibGlzaGVkIHRleHQgc3R5bGVzIChwcmltYXJ5IHNvdXJjZSBvZiB0cnV0aClcbiAgICBjb25zdCB0ZXh0U3R5bGVzID0gc3R5bGVzRGF0YS5tZXRhLnN0eWxlcy5maWx0ZXIoc3R5bGUgPT4gc3R5bGUuc3R5bGVfdHlwZSA9PT0gJ1RFWFQnKTtcblxuICAgIGlmICh0ZXh0U3R5bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OdIEZvdW5kICR7dGV4dFN0eWxlcy5sZW5ndGh9IHB1Ymxpc2hlZCB0ZXh0IHN0eWxlc2ApO1xuXG4gICAgICBmb3IgKGNvbnN0IHN0eWxlIG9mIHRleHRTdHlsZXMpIHtcbiAgICAgICAgY29uc3QgaGllcmFyY2hpY2FsTmFtZSA9IHRoaXMucHJlc2VydmVEZXNpZ25IaWVyYXJjaHkoc3R5bGUubmFtZSk7XG4gICAgICAgIGNvbnN0IHR5cG9ncmFwaHlQcm9wZXJ0aWVzID0gdGhpcy5leHRyYWN0VHlwb2dyYXBoeUZyb21TdHlsZShzdHlsZSwgZmlsZURhdGEpO1xuXG4gICAgICAgIGlmICh0eXBvZ3JhcGh5UHJvcGVydGllcykge1xuICAgICAgICAgIHR5cG9ncmFwaHlbaGllcmFyY2hpY2FsTmFtZV0gPSB7XG4gICAgICAgICAgICAuLi50eXBvZ3JhcGh5UHJvcGVydGllcyxcbiAgICAgICAgICAgIG5hbWU6IHN0eWxlLm5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogc3R5bGUuZGVzY3JpcHRpb24gfHwgJydcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCB0eXBvZ3JhcGh5IGZyb20gVmFyaWFibGVzIChpZiBhdmFpbGFibGUpXG4gICAgLy8gVGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSBtYWluIGV4dHJhY3RUeXBvZ3JhcGh5RnJvbVZhcmlhYmxlcyBtZXRob2Qgbm93XG4gICAgLy8gY29uc3QgdmFyaWFibGVUeXBvZ3JhcGh5ID0gdGhpcy5leHRyYWN0VHlwb2dyYXBoeUZyb21WYXJpYWJsZXMoZmlsZURhdGEpO1xuICAgIC8vIE9iamVjdC5hc3NpZ24odHlwb2dyYXBoeSwgdmFyaWFibGVUeXBvZ3JhcGh5KTtcblxuICAgIGNvbnNvbGUubG9nKGDwn5OKIEV4dHJhY3RlZCAke09iamVjdC5rZXlzKHR5cG9ncmFwaHkpLmxlbmd0aH0gdHlwb2dyYXBoeSB0b2tlbnMgZnJvbSBkZXNpZ24gc3lzdGVtYCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHR5cG9ncmFwaHkpLmxlbmd0aCA+IDAgPyB0eXBvZ3JhcGh5IDogdGhpcy5nZXRGYWxsYmFja1R5cG9ncmFwaHkoKTtcbiAgfVxuXG4gICAgcHJpdmF0ZSBleHRyYWN0VHlwb2dyYXBoeUZyb21WYXJpYWJsZXModmFyaWFibGVzRGF0YTogRmlnbWFWYXJpYWJsZXNSZXNwb25zZSwgZmlsZURhdGE6IEZpZ21hRmlsZVJlc3BvbnNlLCBzdHlsZXNEYXRhOiBGaWdtYVN0eWxlc1Jlc3BvbnNlKTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB7XG4gICAgY29uc3QgdHlwb2dyYXBoeTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuXG4gICAgLy8gRXh0cmFjdCB0eXBvZ3JhcGh5IGZyb20gVmFyaWFibGVzIEFQSSAoY3VycmVudGx5IGxpbWl0ZWQgaW4gRmlnbWEpXG4gICAgLy8gTW9zdCB0eXBvZ3JhcGh5IHZhcmlhYmxlcyBhcmUgc3RpbGwgaGFuZGxlZCB2aWEgdGV4dCBzdHlsZXNcblxuICAgIC8vIEZhbGxiYWNrIHRvIHB1Ymxpc2hlZCB0ZXh0IHN0eWxlc1xuICAgIGNvbnNvbGUubG9nKCfwn5OdIFR5cG9ncmFwaHkgdmFyaWFibGVzIG5vdCBjb21tb25seSBhdmFpbGFibGUsIHVzaW5nIHB1Ymxpc2hlZCB0ZXh0IHN0eWxlcy4uLicpO1xuICAgIHJldHVybiB0aGlzLmV4dHJhY3RUeXBvZ3JhcGh5RnJvbVN0eWxlcyhmaWxlRGF0YSwgc3R5bGVzRGF0YSk7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RUeXBvZ3JhcGh5RnJvbVN0eWxlKHN0eWxlOiBhbnksIGZpbGVEYXRhOiBGaWdtYUZpbGVSZXNwb25zZSk6IGFueSB8IG51bGwge1xuICAgIC8vIFRyeSB0byBmaW5kIHRoZSBhY3R1YWwgdHlwb2dyYXBoeSBwcm9wZXJ0aWVzIGZyb20gdGhlIHN0eWxlcyBvYmplY3QgaW4gZmlsZURhdGFcbiAgICBpZiAoZmlsZURhdGEuc3R5bGVzICYmIGZpbGVEYXRhLnN0eWxlc1tzdHlsZS5rZXldKSB7XG4gICAgICBjb25zdCBzdHlsZURhdGEgPSBmaWxlRGF0YS5zdHlsZXNbc3R5bGUua2V5XTtcbiAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RUeXBvZ3JhcGh5UHJvcGVydGllc0Zyb21TdHlsZURhdGEoc3R5bGVEYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdFR5cG9ncmFwaHlQcm9wZXJ0aWVzRnJvbVN0eWxlRGF0YShzdHlsZURhdGE6IGFueSk6IGFueSB8IG51bGwge1xuICAgIHRyeSB7XG4gICAgICBpZiAoc3R5bGVEYXRhLnN0eWxlKSB7XG4gICAgICAgIGNvbnN0IHRleHRTdHlsZSA9IHN0eWxlRGF0YS5zdHlsZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmb250U2l6ZTogdGV4dFN0eWxlLmZvbnRTaXplIHx8IDE2LFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IHRleHRTdHlsZS5mb250V2VpZ2h0IHx8IDQwMCxcbiAgICAgICAgICBsaW5lSGVpZ2h0OiB0ZXh0U3R5bGUubGluZUhlaWdodFB4ID8gdGV4dFN0eWxlLmxpbmVIZWlnaHRQeCAvICh0ZXh0U3R5bGUuZm9udFNpemUgfHwgMTYpIDogKHRleHRTdHlsZS5saW5lSGVpZ2h0UGVyY2VudCA/IHRleHRTdHlsZS5saW5lSGVpZ2h0UGVyY2VudCAvIDEwMCA6IDEuNCksXG4gICAgICAgICAgZm9udEZhbWlseTogdGV4dFN0eWxlLmZvbnRGYW1pbHkgfHwgJ0ludGVyJyxcbiAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiB0ZXh0U3R5bGUubGV0dGVyU3BhY2luZyB8fCAwLFxuICAgICAgICAgIHRleHRUcmFuc2Zvcm06IHRleHRTdHlsZS50ZXh0Q2FzZSB8fCAnbm9uZSdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gU2lsZW50IGZhaWwgZm9yIG5vd1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgdHJhdmVyc2VOb2Rlc0ZvclR5cG9ncmFwaHkobm9kZTogYW55LCB0ZXh0U3R5bGVzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KSB7XG4gICAgaWYgKCFub2RlKSByZXR1cm47XG5cbiAgICAvLyBFeHRyYWN0IHRleHQgcHJvcGVydGllcyBmcm9tIFRFWFQgbm9kZXNcbiAgICBpZiAobm9kZS50eXBlID09PSAnVEVYVCcgJiYgbm9kZS5zdHlsZSkge1xuICAgICAgY29uc3Qgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgICAgY29uc3Qgc3R5bGVLZXkgPSB0aGlzLmdlbmVyYXRlVHlwb2dyYXBoeUtleShzdHlsZSk7XG5cbiAgICAgIGlmICghdGV4dFN0eWxlc1tzdHlsZUtleV0pIHtcbiAgICAgICAgdGV4dFN0eWxlc1tzdHlsZUtleV0gPSB7XG4gICAgICAgICAgZm9udFNpemU6IHN0eWxlLmZvbnRTaXplIHx8IDE2LFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IHN0eWxlLmZvbnRXZWlnaHQgfHwgNDAwLFxuICAgICAgICAgIGxpbmVIZWlnaHQ6IHN0eWxlLmxpbmVIZWlnaHRQeCA/IHN0eWxlLmxpbmVIZWlnaHRQeCAvIChzdHlsZS5mb250U2l6ZSB8fCAxNikgOiAxLjQsXG4gICAgICAgICAgZm9udEZhbWlseTogc3R5bGUuZm9udEZhbWlseSB8fCAnSW50ZXInLFxuICAgICAgICAgIGxldHRlclNwYWNpbmc6IHN0eWxlLmxldHRlclNwYWNpbmcgfHwgMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGNoaWxkcmVuXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4gJiYgQXJyYXkuaXNBcnJheShub2RlLmNoaWxkcmVuKSkge1xuICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZDogYW55KSA9PiB7XG4gICAgICAgIHRoaXMudHJhdmVyc2VOb2Rlc0ZvclR5cG9ncmFwaHkoY2hpbGQsIHRleHRTdHlsZXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZVR5cG9ncmFwaHlLZXkoc3R5bGU6IGFueSk6IHN0cmluZyB7XG4gICAgY29uc3QgZm9udFNpemUgPSBzdHlsZS5mb250U2l6ZSB8fCAxNjtcbiAgICBjb25zdCBmb250V2VpZ2h0ID0gc3R5bGUuZm9udFdlaWdodCB8fCA0MDA7XG5cbiAgICAvLyBHZW5lcmF0ZSBzZW1hbnRpYyBuYW1lcyBiYXNlZCBvbiBzaXplIGFuZCB3ZWlnaHRcbiAgICBpZiAoZm9udFNpemUgPj0gMzIpIHJldHVybiBmb250V2VpZ2h0ID49IDYwMCA/ICdoZWFkaW5nLXhsJyA6ICdkaXNwbGF5LXhsJztcbiAgICBpZiAoZm9udFNpemUgPj0gMjQpIHJldHVybiBmb250V2VpZ2h0ID49IDYwMCA/ICdoZWFkaW5nLWxnJyA6ICdkaXNwbGF5LWxnJztcbiAgICBpZiAoZm9udFNpemUgPj0gMjApIHJldHVybiBmb250V2VpZ2h0ID49IDYwMCA/ICdoZWFkaW5nLW1kJyA6ICdkaXNwbGF5LW1kJztcbiAgICBpZiAoZm9udFNpemUgPj0gMTgpIHJldHVybiBmb250V2VpZ2h0ID49IDYwMCA/ICdoZWFkaW5nLXNtJyA6ICd0ZXh0LWxnJztcbiAgICBpZiAoZm9udFNpemUgPj0gMTYpIHJldHVybiBmb250V2VpZ2h0ID49IDYwMCA/ICd0ZXh0LWJvbGQnIDogJ3RleHQtYmFzZSc7XG4gICAgaWYgKGZvbnRTaXplID49IDE0KSByZXR1cm4gJ3RleHQtc20nO1xuICAgIHJldHVybiAndGV4dC14cyc7XG4gIH1cblxuICBwcml2YXRlIGdldEZhbGxiYWNrVHlwb2dyYXBoeSgpOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgJ2hlYWRpbmcteGwnOiB7XG4gICAgICAgIGZvbnRTaXplOiAzMixcbiAgICAgICAgZm9udFdlaWdodDogNzAwLFxuICAgICAgICBsaW5lSGVpZ2h0OiAxLjJcbiAgICAgIH0sXG4gICAgICAnaGVhZGluZy1sZyc6IHtcbiAgICAgICAgZm9udFNpemU6IDI0LFxuICAgICAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgICAgIGxpbmVIZWlnaHQ6IDEuM1xuICAgICAgfSxcbiAgICAgICdib2R5Jzoge1xuICAgICAgICBmb250U2l6ZTogMTYsXG4gICAgICAgIGZvbnRXZWlnaHQ6IDQwMCxcbiAgICAgICAgbGluZUhlaWdodDogMS41XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdFNwYWNpbmcoZmlsZURhdGE6IEZpZ21hRmlsZVJlc3BvbnNlKTogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSB7XG4gICAgY29uc3Qgc3BhY2luZzogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xuICAgIGNvbnN0IHNwYWNpbmdDb3VudHM6IHsgW3NwYWNpbmc6IG51bWJlcl06IG51bWJlciB9ID0ge307XG5cbiAgICAvLyBFeHRyYWN0IHNwYWNpbmcgZnJvbSBBdXRvIExheW91dCBub2Rlc1xuICAgIHRoaXMudHJhdmVyc2VOb2Rlc0ZvclNwYWNpbmcoZmlsZURhdGEuZG9jdW1lbnQsIHNwYWNpbmdDb3VudHMpO1xuXG4gICAgLy8gQ29udmVydCB0byB0b2tlbnMgd2l0aCBzZW1hbnRpYyBuYW1lc1xuICAgIE9iamVjdC5lbnRyaWVzKHNwYWNpbmdDb3VudHMpXG4gICAgICAuc29ydCgoWyxhXSwgWyxiXSkgPT4gYiAtIGEpXG4gICAgICAuc2xpY2UoMCwgMTUpXG4gICAgICAuZm9yRWFjaCgoW3NwYWNlLCBjb3VudF0sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHRva2VuTmFtZSA9IHRoaXMuZ2VuZXJhdGVTcGFjaW5nTmFtZShOdW1iZXIoc3BhY2UpKTtcbiAgICAgICAgc3BhY2luZ1t0b2tlbk5hbWVdID0gTnVtYmVyKHNwYWNlKTtcbiAgICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coYPCfk4ogRm91bmQgJHtPYmplY3Qua2V5cyhzcGFjaW5nKS5sZW5ndGh9IHNwYWNpbmcgdG9rZW5zYCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNwYWNpbmcpLmxlbmd0aCA+IDAgPyBzcGFjaW5nIDogdGhpcy5nZXRGYWxsYmFja1NwYWNpbmcoKTtcbiAgfVxuXG4gIHByaXZhdGUgdHJhdmVyc2VOb2Rlc0ZvclNwYWNpbmcobm9kZTogYW55LCBzcGFjaW5nQ291bnRzOiB7IFtzcGFjaW5nOiBudW1iZXJdOiBudW1iZXIgfSkge1xuICAgIGlmICghbm9kZSkgcmV0dXJuO1xuXG4gICAgLy8gRXh0cmFjdCBBdXRvIExheW91dCBzcGFjaW5nXG4gICAgaWYgKG5vZGUubGF5b3V0TW9kZSAmJiBub2RlLml0ZW1TcGFjaW5nICYmIHR5cGVvZiBub2RlLml0ZW1TcGFjaW5nID09PSAnbnVtYmVyJykge1xuICAgICAgc3BhY2luZ0NvdW50c1tub2RlLml0ZW1TcGFjaW5nXSA9IChzcGFjaW5nQ291bnRzW25vZGUuaXRlbVNwYWNpbmddIHx8IDApICsgMTtcbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IHBhZGRpbmcgZnJvbSBBdXRvIExheW91dFxuICAgIGlmIChub2RlLnBhZGRpbmdMZWZ0ICYmIHR5cGVvZiBub2RlLnBhZGRpbmdMZWZ0ID09PSAnbnVtYmVyJykge1xuICAgICAgc3BhY2luZ0NvdW50c1tub2RlLnBhZGRpbmdMZWZ0XSA9IChzcGFjaW5nQ291bnRzW25vZGUucGFkZGluZ0xlZnRdIHx8IDApICsgMTtcbiAgICB9XG4gICAgaWYgKG5vZGUucGFkZGluZ1RvcCAmJiB0eXBlb2Ygbm9kZS5wYWRkaW5nVG9wID09PSAnbnVtYmVyJykge1xuICAgICAgc3BhY2luZ0NvdW50c1tub2RlLnBhZGRpbmdUb3BdID0gKHNwYWNpbmdDb3VudHNbbm9kZS5wYWRkaW5nVG9wXSB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgLy8gUmVjdXJzaXZlbHkgdHJhdmVyc2UgY2hpbGRyZW5cbiAgICBpZiAobm9kZS5jaGlsZHJlbiAmJiBBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkOiBhbnkpID0+IHtcbiAgICAgICAgdGhpcy50cmF2ZXJzZU5vZGVzRm9yU3BhY2luZyhjaGlsZCwgc3BhY2luZ0NvdW50cyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlU3BhY2luZ05hbWUoc3BhY2luZzogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBpZiAoc3BhY2luZyA9PT0gMCkgcmV0dXJuICdub25lJztcbiAgICBpZiAoc3BhY2luZyA8PSAyKSByZXR1cm4gJ3hzJztcbiAgICBpZiAoc3BhY2luZyA8PSA0KSByZXR1cm4gJ3NtJztcbiAgICBpZiAoc3BhY2luZyA8PSA4KSByZXR1cm4gJ21kJztcbiAgICBpZiAoc3BhY2luZyA8PSAxMikgcmV0dXJuICdsZyc7XG4gICAgaWYgKHNwYWNpbmcgPD0gMTYpIHJldHVybiAneGwnO1xuICAgIGlmIChzcGFjaW5nIDw9IDI0KSByZXR1cm4gJzJ4bCc7XG4gICAgaWYgKHNwYWNpbmcgPD0gMzIpIHJldHVybiAnM3hsJztcbiAgICBpZiAoc3BhY2luZyA8PSA0OCkgcmV0dXJuICc0eGwnO1xuICAgIHJldHVybiAnNXhsJztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RmFsbGJhY2tTcGFjaW5nKCk6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0ge1xuICAgIHJldHVybiB7XG4gICAgICB4czogNCxcbiAgICAgIHNtOiA4LFxuICAgICAgbWQ6IDE2LFxuICAgICAgbGc6IDI0LFxuICAgICAgeGw6IDMyXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdEVmZmVjdHNGcm9tU3R5bGVzKGZpbGVEYXRhOiBGaWdtYUZpbGVSZXNwb25zZSwgc3R5bGVzRGF0YTogRmlnbWFTdHlsZXNSZXNwb25zZSk6IHsgW2tleTogc3RyaW5nXTogYW55IH0ge1xuICAgIGNvbnN0IGVmZmVjdHM6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fTtcblxuICAgIC8vIEV4dHJhY3QgZWZmZWN0cyBmcm9tIHB1Ymxpc2hlZCBlZmZlY3Qgc3R5bGVzIChwcmltYXJ5IHNvdXJjZSBvZiB0cnV0aClcbiAgICBjb25zdCBlZmZlY3RTdHlsZXMgPSBzdHlsZXNEYXRhLm1ldGEuc3R5bGVzLmZpbHRlcihzdHlsZSA9PiBzdHlsZS5zdHlsZV90eXBlID09PSAnRUZGRUNUJyk7XG5cbiAgICBpZiAoZWZmZWN0U3R5bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGDinKggRm91bmQgJHtlZmZlY3RTdHlsZXMubGVuZ3RofSBwdWJsaXNoZWQgZWZmZWN0IHN0eWxlc2ApO1xuXG4gICAgICBmb3IgKGNvbnN0IHN0eWxlIG9mIGVmZmVjdFN0eWxlcykge1xuICAgICAgICBjb25zdCBoaWVyYXJjaGljYWxOYW1lID0gdGhpcy5wcmVzZXJ2ZURlc2lnbkhpZXJhcmNoeShzdHlsZS5uYW1lKTtcbiAgICAgICAgY29uc3QgZWZmZWN0UHJvcGVydGllcyA9IHRoaXMuZXh0cmFjdEVmZmVjdEZyb21TdHlsZShzdHlsZSwgZmlsZURhdGEpO1xuXG4gICAgICAgIGlmIChlZmZlY3RQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgZWZmZWN0c1toaWVyYXJjaGljYWxOYW1lXSA9IHtcbiAgICAgICAgICAgIC4uLmVmZmVjdFByb3BlcnRpZXMsXG4gICAgICAgICAgICBuYW1lOiBzdHlsZS5uYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHN0eWxlLmRlc2NyaXB0aW9uIHx8ICcnXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV4dHJhY3QgZWZmZWN0cyBmcm9tIFZhcmlhYmxlcyAoaWYgYXZhaWxhYmxlKVxuICAgIGNvbnN0IHZhcmlhYmxlRWZmZWN0cyA9IHRoaXMuZXh0cmFjdEVmZmVjdHNGcm9tVmFyaWFibGVzKGZpbGVEYXRhKTtcbiAgICBPYmplY3QuYXNzaWduKGVmZmVjdHMsIHZhcmlhYmxlRWZmZWN0cyk7XG5cbiAgICBjb25zb2xlLmxvZyhg8J+TiiBFeHRyYWN0ZWQgJHtPYmplY3Qua2V5cyhlZmZlY3RzKS5sZW5ndGh9IGVmZmVjdCB0b2tlbnMgZnJvbSBkZXNpZ24gc3lzdGVtYCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGVmZmVjdHMpLmxlbmd0aCA+IDAgPyBlZmZlY3RzIDogdGhpcy5nZXRGYWxsYmFja0VmZmVjdHMoKTtcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdEVmZmVjdHNGcm9tVmFyaWFibGVzKGZpbGVEYXRhOiBGaWdtYUZpbGVSZXNwb25zZSk6IHsgW2tleTogc3RyaW5nXTogYW55IH0ge1xuICAgIGNvbnN0IGVmZmVjdHM6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fTtcblxuICAgIC8vIENoZWNrIGlmIGZpbGUgaGFzIGVmZmVjdCB2YXJpYWJsZXNcbiAgICBpZiAoZmlsZURhdGEuc3R5bGVzICYmIHR5cGVvZiBmaWxlRGF0YS5zdHlsZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhmaWxlRGF0YS5zdHlsZXMpLmZvckVhY2goKFtzdHlsZUlkLCBzdHlsZURhdGFdOiBbc3RyaW5nLCBhbnldKSA9PiB7XG4gICAgICAgIGlmIChzdHlsZURhdGEuc3R5bGVUeXBlID09PSAnRUZGRUNUJyAmJiBzdHlsZURhdGEubmFtZSkge1xuICAgICAgICAgIGNvbnN0IGhpZXJhcmNoaWNhbE5hbWUgPSB0aGlzLnByZXNlcnZlRGVzaWduSGllcmFyY2h5KHN0eWxlRGF0YS5uYW1lKTtcbiAgICAgICAgICBjb25zdCBlZmZlY3RQcm9wZXJ0aWVzID0gdGhpcy5leHRyYWN0RWZmZWN0UHJvcGVydGllc0Zyb21TdHlsZURhdGEoc3R5bGVEYXRhKTtcbiAgICAgICAgICBpZiAoZWZmZWN0UHJvcGVydGllcykge1xuICAgICAgICAgICAgZWZmZWN0c1toaWVyYXJjaGljYWxOYW1lXSA9IGVmZmVjdFByb3BlcnRpZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWZmZWN0cztcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdEVmZmVjdEZyb21TdHlsZShzdHlsZTogYW55LCBmaWxlRGF0YTogRmlnbWFGaWxlUmVzcG9uc2UpOiBhbnkgfCBudWxsIHtcbiAgICAvLyBUcnkgdG8gZmluZCB0aGUgYWN0dWFsIGVmZmVjdCBwcm9wZXJ0aWVzIGZyb20gdGhlIHN0eWxlcyBvYmplY3QgaW4gZmlsZURhdGFcbiAgICBpZiAoZmlsZURhdGEuc3R5bGVzICYmIGZpbGVEYXRhLnN0eWxlc1tzdHlsZS5rZXldKSB7XG4gICAgICBjb25zdCBzdHlsZURhdGEgPSBmaWxlRGF0YS5zdHlsZXNbc3R5bGUua2V5XTtcbiAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RFZmZlY3RQcm9wZXJ0aWVzRnJvbVN0eWxlRGF0YShzdHlsZURhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0RWZmZWN0UHJvcGVydGllc0Zyb21TdHlsZURhdGEoc3R5bGVEYXRhOiBhbnkpOiBhbnkgfCBudWxsIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHN0eWxlRGF0YS5lZmZlY3RzICYmIHN0eWxlRGF0YS5lZmZlY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gc3R5bGVEYXRhLmVmZmVjdHNbMF07IC8vIFRha2UgdGhlIGZpcnN0IGVmZmVjdFxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09ICdEUk9QX1NIQURPVycgfHwgZWZmZWN0LnR5cGUgPT09ICdJTk5FUl9TSEFET1cnKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVmZmVjdC50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICcnKSxcbiAgICAgICAgICAgIHg6IGVmZmVjdC5vZmZzZXQ/LnggfHwgMCxcbiAgICAgICAgICAgIHk6IGVmZmVjdC5vZmZzZXQ/LnkgfHwgMCxcbiAgICAgICAgICAgIGJsdXI6IGVmZmVjdC5yYWRpdXMgfHwgMCxcbiAgICAgICAgICAgIHNwcmVhZDogZWZmZWN0LnNwcmVhZCB8fCAwLFxuICAgICAgICAgICAgY29sb3I6IGVmZmVjdC5jb2xvciA/IHRoaXMucmdiYVRvU3RyaW5nKGVmZmVjdC5jb2xvcikgOiAncmdiYSgwLCAwLCAwLCAwLjEpJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gU2lsZW50IGZhaWwgZm9yIG5vd1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgdHJhdmVyc2VOb2Rlc0ZvckVmZmVjdHMobm9kZTogYW55LCBlZmZlY3RzRm91bmQ6IEFycmF5PGFueT4pIHtcbiAgICBpZiAoIW5vZGUpIHJldHVybjtcblxuICAgIC8vIEV4dHJhY3QgZWZmZWN0c1xuICAgIGlmIChub2RlLmVmZmVjdHMgJiYgQXJyYXkuaXNBcnJheShub2RlLmVmZmVjdHMpKSB7XG4gICAgICBub2RlLmVmZmVjdHMuZm9yRWFjaCgoZWZmZWN0OiBhbnkpID0+IHtcbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSAnRFJPUF9TSEFET1cnIHx8IGVmZmVjdC50eXBlID09PSAnSU5ORVJfU0hBRE9XJykge1xuICAgICAgICAgIGVmZmVjdHNGb3VuZC5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IGVmZmVjdC50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICcnKSxcbiAgICAgICAgICAgIHg6IGVmZmVjdC5vZmZzZXQ/LnggfHwgMCxcbiAgICAgICAgICAgIHk6IGVmZmVjdC5vZmZzZXQ/LnkgfHwgMCxcbiAgICAgICAgICAgIGJsdXI6IGVmZmVjdC5yYWRpdXMgfHwgMCxcbiAgICAgICAgICAgIHNwcmVhZDogZWZmZWN0LnNwcmVhZCB8fCAwLFxuICAgICAgICAgICAgY29sb3I6IGVmZmVjdC5jb2xvciA/IHRoaXMucmdiYVRvU3RyaW5nKGVmZmVjdC5jb2xvcikgOiAncmdiYSgwLCAwLCAwLCAwLjEpJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZWN1cnNpdmVseSB0cmF2ZXJzZSBjaGlsZHJlblxuICAgIGlmIChub2RlLmNoaWxkcmVuICYmIEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQ6IGFueSkgPT4ge1xuICAgICAgICB0aGlzLnRyYXZlcnNlTm9kZXNGb3JFZmZlY3RzKGNoaWxkLCBlZmZlY3RzRm91bmQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZUVmZmVjdE5hbWUoZWZmZWN0OiBhbnksIGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IGJsdXIgPSBlZmZlY3QuYmx1ciB8fCAwO1xuICAgIGlmIChibHVyIDw9IDIpIHJldHVybiBgc2hhZG93LXhzYDtcbiAgICBpZiAoYmx1ciA8PSA0KSByZXR1cm4gYHNoYWRvdy1zbWA7XG4gICAgaWYgKGJsdXIgPD0gOCkgcmV0dXJuIGBzaGFkb3ctbWRgO1xuICAgIGlmIChibHVyIDw9IDE2KSByZXR1cm4gYHNoYWRvdy1sZ2A7XG4gICAgcmV0dXJuIGBzaGFkb3cteGxgO1xuICB9XG5cbiAgcHJpdmF0ZSByZ2JhVG9TdHJpbmcoY29sb3I6IHsgcjogbnVtYmVyOyBnOiBudW1iZXI7IGI6IG51bWJlcjsgYT86IG51bWJlciB9KTogc3RyaW5nIHtcbiAgICBjb25zdCByID0gTWF0aC5yb3VuZChjb2xvci5yICogMjU1KTtcbiAgICBjb25zdCBnID0gTWF0aC5yb3VuZChjb2xvci5nICogMjU1KTtcbiAgICBjb25zdCBiID0gTWF0aC5yb3VuZChjb2xvci5iICogMjU1KTtcbiAgICBjb25zdCBhID0gY29sb3IuYSAhPT0gdW5kZWZpbmVkID8gY29sb3IuYSA6IDE7XG4gICAgcmV0dXJuIGByZ2JhKCR7cn0sICR7Z30sICR7Yn0sICR7YX0pYDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RmFsbGJhY2tFZmZlY3RzKCk6IHsgW2tleTogc3RyaW5nXTogYW55IH0ge1xuICAgIHJldHVybiB7XG4gICAgICAnc2hhZG93LXNtJzoge1xuICAgICAgICB0eXBlOiAnZHJvcFNoYWRvdycsXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDEsXG4gICAgICAgIGJsdXI6IDMsXG4gICAgICAgIHNwcmVhZDogMCxcbiAgICAgICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMSknXG4gICAgICB9LFxuICAgICAgJ3NoYWRvdy1sZyc6IHtcbiAgICAgICAgdHlwZTogJ2Ryb3BTaGFkb3cnLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiA0LFxuICAgICAgICBibHVyOiA2LFxuICAgICAgICBzcHJlYWQ6IC0xLFxuICAgICAgICBjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4xKSdcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0Qm9yZGVyUmFkaXVzKGZpbGVEYXRhOiBGaWdtYUZpbGVSZXNwb25zZSk6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0ge1xuICAgIGNvbnN0IGJvcmRlclJhZGl1czogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xuICAgIGNvbnN0IHJhZGl1c0NvdW50czogeyBbcmFkaXVzOiBudW1iZXJdOiBudW1iZXIgfSA9IHt9O1xuXG4gICAgLy8gRXh0cmFjdCBib3JkZXIgcmFkaXVzIGZyb20gZG9jdW1lbnQgbm9kZXNcbiAgICB0aGlzLnRyYXZlcnNlTm9kZXNGb3JCb3JkZXJSYWRpdXMoZmlsZURhdGEuZG9jdW1lbnQsIHJhZGl1c0NvdW50cyk7XG5cbiAgICAvLyBDb252ZXJ0IHRvIHRva2Vuc1xuICAgIE9iamVjdC5lbnRyaWVzKHJhZGl1c0NvdW50cylcbiAgICAgIC5zb3J0KChbLGFdLCBbLGJdKSA9PiBiIC0gYSlcbiAgICAgIC5zbGljZSgwLCAxMClcbiAgICAgIC5mb3JFYWNoKChbcmFkaXVzLCBjb3VudF0sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHRva2VuTmFtZSA9IHRoaXMuZ2VuZXJhdGVCb3JkZXJSYWRpdXNOYW1lKE51bWJlcihyYWRpdXMpKTtcbiAgICAgICAgYm9yZGVyUmFkaXVzW3Rva2VuTmFtZV0gPSBOdW1iZXIocmFkaXVzKTtcbiAgICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coYPCfk4ogRm91bmQgJHtPYmplY3Qua2V5cyhib3JkZXJSYWRpdXMpLmxlbmd0aH0gYm9yZGVyIHJhZGl1cyB0b2tlbnNgKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYm9yZGVyUmFkaXVzKS5sZW5ndGggPiAwID8gYm9yZGVyUmFkaXVzIDogdGhpcy5nZXRGYWxsYmFja0JvcmRlclJhZGl1cygpO1xuICB9XG5cbiAgcHJpdmF0ZSB0cmF2ZXJzZU5vZGVzRm9yQm9yZGVyUmFkaXVzKG5vZGU6IGFueSwgcmFkaXVzQ291bnRzOiB7IFtyYWRpdXM6IG51bWJlcl06IG51bWJlciB9KSB7XG4gICAgaWYgKCFub2RlKSByZXR1cm47XG5cbiAgICAvLyBFeHRyYWN0IGNvcm5lciByYWRpdXMgZnJvbSByZWN0YW5nbGVzIGFuZCBvdGhlciBzaGFwZXNcbiAgICBpZiAobm9kZS50eXBlID09PSAnUkVDVEFOR0xFJyB8fCBub2RlLnR5cGUgPT09ICdGUkFNRScpIHtcbiAgICAgIGlmIChub2RlLmNvcm5lclJhZGl1cyAmJiB0eXBlb2Ygbm9kZS5jb3JuZXJSYWRpdXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJhZGl1c0NvdW50c1tub2RlLmNvcm5lclJhZGl1c10gPSAocmFkaXVzQ291bnRzW25vZGUuY29ybmVyUmFkaXVzXSB8fCAwKSArIDE7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBpbmRpdmlkdWFsIGNvcm5lciByYWRpdXNcbiAgICAgIGlmIChub2RlLnJlY3RhbmdsZUNvcm5lclJhZGlpICYmIEFycmF5LmlzQXJyYXkobm9kZS5yZWN0YW5nbGVDb3JuZXJSYWRpaSkpIHtcbiAgICAgICAgbm9kZS5yZWN0YW5nbGVDb3JuZXJSYWRpaS5mb3JFYWNoKChyYWRpdXM6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgcmFkaXVzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmFkaXVzQ291bnRzW3JhZGl1c10gPSAocmFkaXVzQ291bnRzW3JhZGl1c10gfHwgMCkgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVjdXJzaXZlbHkgdHJhdmVyc2UgY2hpbGRyZW5cbiAgICBpZiAobm9kZS5jaGlsZHJlbiAmJiBBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkOiBhbnkpID0+IHtcbiAgICAgICAgdGhpcy50cmF2ZXJzZU5vZGVzRm9yQm9yZGVyUmFkaXVzKGNoaWxkLCByYWRpdXNDb3VudHMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZUJvcmRlclJhZGl1c05hbWUocmFkaXVzOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGlmIChyYWRpdXMgPT09IDApIHJldHVybiAnbm9uZSc7XG4gICAgaWYgKHJhZGl1cyA8PSAyKSByZXR1cm4gJ3NtJztcbiAgICBpZiAocmFkaXVzIDw9IDQpIHJldHVybiAnbWQnO1xuICAgIGlmIChyYWRpdXMgPD0gOCkgcmV0dXJuICdsZyc7XG4gICAgaWYgKHJhZGl1cyA8PSAxMikgcmV0dXJuICd4bCc7XG4gICAgaWYgKHJhZGl1cyA8PSAxNikgcmV0dXJuICcyeGwnO1xuICAgIGlmIChyYWRpdXMgPj0gOTk5OSB8fCByYWRpdXMgPj0gMTAwMCkgcmV0dXJuICdmdWxsJztcbiAgICByZXR1cm4gJzN4bCc7XG4gIH1cblxuICBwcml2YXRlIGdldEZhbGxiYWNrQm9yZGVyUmFkaXVzKCk6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0ge1xuICAgIHJldHVybiB7XG4gICAgICBub25lOiAwLFxuICAgICAgc206IDIsXG4gICAgICBtZDogNCxcbiAgICAgIGxnOiA4LFxuICAgICAgeGw6IDEyLFxuICAgICAgZnVsbDogOTk5OVxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RTdHJva2VXZWlnaHRzKGZpbGVEYXRhOiBGaWdtYUZpbGVSZXNwb25zZSk6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0ge1xuICAgIGNvbnN0IHN0cm9rZVdlaWdodHM6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7fTtcbiAgICBjb25zdCB3ZWlnaHRDb3VudHM6IHsgW3dlaWdodDogbnVtYmVyXTogbnVtYmVyIH0gPSB7fTtcblxuICAgIC8vIEV4dHJhY3Qgc3Ryb2tlIHdlaWdodHMgZnJvbSBkb2N1bWVudCBub2Rlc1xuICAgIHRoaXMudHJhdmVyc2VOb2Rlc0ZvclN0cm9rZXMoZmlsZURhdGEuZG9jdW1lbnQsIHdlaWdodENvdW50cyk7XG5cbiAgICAvLyBDb252ZXJ0IHRvIHRva2Vuc1xuICAgIE9iamVjdC5lbnRyaWVzKHdlaWdodENvdW50cylcbiAgICAgIC5zb3J0KChbLGFdLCBbLGJdKSA9PiBiIC0gYSlcbiAgICAgIC5zbGljZSgwLCAxMClcbiAgICAgIC5mb3JFYWNoKChbd2VpZ2h0LCBjb3VudF0sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHRva2VuTmFtZSA9IHRoaXMuZ2VuZXJhdGVTdHJva2VXZWlnaHROYW1lKE51bWJlcih3ZWlnaHQpKTtcbiAgICAgICAgc3Ryb2tlV2VpZ2h0c1t0b2tlbk5hbWVdID0gTnVtYmVyKHdlaWdodCk7XG4gICAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKGDwn5OKIEZvdW5kICR7T2JqZWN0LmtleXMoc3Ryb2tlV2VpZ2h0cykubGVuZ3RofSBzdHJva2Ugd2VpZ2h0IHRva2Vuc2ApO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdHJva2VXZWlnaHRzKS5sZW5ndGggPiAwID8gc3Ryb2tlV2VpZ2h0cyA6IHRoaXMuZ2V0RmFsbGJhY2tTdHJva2VXZWlnaHRzKCk7XG4gIH1cblxuICBwcml2YXRlIHRyYXZlcnNlTm9kZXNGb3JTdHJva2VzKG5vZGU6IGFueSwgd2VpZ2h0Q291bnRzOiB7IFt3ZWlnaHQ6IG51bWJlcl06IG51bWJlciB9KSB7XG4gICAgaWYgKCFub2RlKSByZXR1cm47XG5cbiAgICAvLyBFeHRyYWN0IHN0cm9rZSB3ZWlnaHRzXG4gICAgaWYgKG5vZGUuc3Ryb2tlV2VpZ2h0ICYmIHR5cGVvZiBub2RlLnN0cm9rZVdlaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHdlaWdodENvdW50c1tub2RlLnN0cm9rZVdlaWdodF0gPSAod2VpZ2h0Q291bnRzW25vZGUuc3Ryb2tlV2VpZ2h0XSB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgLy8gUmVjdXJzaXZlbHkgdHJhdmVyc2UgY2hpbGRyZW5cbiAgICBpZiAobm9kZS5jaGlsZHJlbiAmJiBBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkOiBhbnkpID0+IHtcbiAgICAgICAgdGhpcy50cmF2ZXJzZU5vZGVzRm9yU3Ryb2tlcyhjaGlsZCwgd2VpZ2h0Q291bnRzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVTdHJva2VXZWlnaHROYW1lKHdlaWdodDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBpZiAod2VpZ2h0IDw9IDEpIHJldHVybiAndGhpbic7XG4gICAgaWYgKHdlaWdodCA8PSAyKSByZXR1cm4gJ25vcm1hbCc7XG4gICAgaWYgKHdlaWdodCA8PSA0KSByZXR1cm4gJ21lZGl1bSc7XG4gICAgaWYgKHdlaWdodCA8PSA2KSByZXR1cm4gJ3RoaWNrJztcbiAgICByZXR1cm4gJ2V4dHJhLXRoaWNrJztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RmFsbGJhY2tTdHJva2VXZWlnaHRzKCk6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0ge1xuICAgIHJldHVybiB7XG4gICAgICB0aGluOiAxLFxuICAgICAgbm9ybWFsOiAyLFxuICAgICAgdGhpY2s6IDRcbiAgICB9O1xuICB9XG5cbiAgICBwcml2YXRlIGV4dHJhY3RTcGFjaW5nRnJvbVZhcmlhYmxlcyh2YXJpYWJsZXNEYXRhOiBGaWdtYVZhcmlhYmxlc1Jlc3BvbnNlKTogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSB7XG4gICAgY29uc3Qgc3BhY2luZzogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xuXG4gICAgLy8gRXh0cmFjdCBzcGFjaW5nIGZyb20gVmFyaWFibGVzIEFQSVxuICAgIGlmICh2YXJpYWJsZXNEYXRhLm1ldGEudmFyaWFibGVzKSB7XG4gICAgICBPYmplY3QuZW50cmllcyh2YXJpYWJsZXNEYXRhLm1ldGEudmFyaWFibGVzKS5mb3JFYWNoKChbdmFyaWFibGVJZCwgdmFyaWFibGVdKSA9PiB7XG4gICAgICAgIGlmICh2YXJpYWJsZS5yZXNvbHZlZFR5cGUgPT09ICdGTE9BVCcgJiYgdmFyaWFibGUubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdzcGFjaW5nJykpIHtcbiAgICAgICAgICBjb25zdCBoaWVyYXJjaGljYWxOYW1lID0gdGhpcy5wcmVzZXJ2ZURlc2lnbkhpZXJhcmNoeSh2YXJpYWJsZS5uYW1lKTtcbiAgICAgICAgICBjb25zdCBzcGFjaW5nVmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1iZXJGcm9tVmFyaWFibGUodmFyaWFibGUsIHZhcmlhYmxlc0RhdGEpO1xuXG4gICAgICAgICAgaWYgKHNwYWNpbmdWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3BhY2luZ1toaWVyYXJjaGljYWxOYW1lXSA9IHNwYWNpbmdWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGDwn5OKIEV4dHJhY3RlZCAke09iamVjdC5rZXlzKHNwYWNpbmcpLmxlbmd0aH0gc3BhY2luZyB0b2tlbnMgZnJvbSB2YXJpYWJsZXNgKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3BhY2luZykubGVuZ3RoID4gMCA/IHNwYWNpbmcgOiB0aGlzLmdldEZhbGxiYWNrU3BhY2luZygpO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0Qm9yZGVyUmFkaXVzRnJvbVZhcmlhYmxlcyh2YXJpYWJsZXNEYXRhOiBGaWdtYVZhcmlhYmxlc1Jlc3BvbnNlKTogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSB7XG4gICAgY29uc3QgYm9yZGVyUmFkaXVzOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge307XG5cbiAgICAvLyBFeHRyYWN0IGJvcmRlciByYWRpdXMgZnJvbSBWYXJpYWJsZXMgQVBJXG4gICAgaWYgKHZhcmlhYmxlc0RhdGEubWV0YS52YXJpYWJsZXMpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHZhcmlhYmxlc0RhdGEubWV0YS52YXJpYWJsZXMpLmZvckVhY2goKFt2YXJpYWJsZUlkLCB2YXJpYWJsZV0pID0+IHtcbiAgICAgICAgaWYgKHZhcmlhYmxlLnJlc29sdmVkVHlwZSA9PT0gJ0ZMT0FUJyAmJiAodmFyaWFibGUubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdyYWRpdXMnKSB8fCB2YXJpYWJsZS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2JvcmRlcicpKSkge1xuICAgICAgICAgIGNvbnN0IGhpZXJhcmNoaWNhbE5hbWUgPSB0aGlzLnByZXNlcnZlRGVzaWduSGllcmFyY2h5KHZhcmlhYmxlLm5hbWUpO1xuICAgICAgICAgIGNvbnN0IHJhZGl1c1ZhbHVlID0gdGhpcy5leHRyYWN0TnVtYmVyRnJvbVZhcmlhYmxlKHZhcmlhYmxlLCB2YXJpYWJsZXNEYXRhKTtcblxuICAgICAgICAgIGlmIChyYWRpdXNWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYm9yZGVyUmFkaXVzW2hpZXJhcmNoaWNhbE5hbWVdID0gcmFkaXVzVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhg8J+TiiBFeHRyYWN0ZWQgJHtPYmplY3Qua2V5cyhib3JkZXJSYWRpdXMpLmxlbmd0aH0gYm9yZGVyIHJhZGl1cyB0b2tlbnMgZnJvbSB2YXJpYWJsZXNgKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYm9yZGVyUmFkaXVzKS5sZW5ndGggPiAwID8gYm9yZGVyUmFkaXVzIDogdGhpcy5nZXRGYWxsYmFja0JvcmRlclJhZGl1cygpO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0U3Ryb2tlV2VpZ2h0c0Zyb21WYXJpYWJsZXModmFyaWFibGVzRGF0YTogRmlnbWFWYXJpYWJsZXNSZXNwb25zZSk6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0ge1xuICAgIGNvbnN0IHN0cm9rZVdlaWdodHM6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7fTtcblxuICAgIC8vIEV4dHJhY3Qgc3Ryb2tlIHdlaWdodHMgZnJvbSBWYXJpYWJsZXMgQVBJXG4gICAgaWYgKHZhcmlhYmxlc0RhdGEubWV0YS52YXJpYWJsZXMpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHZhcmlhYmxlc0RhdGEubWV0YS52YXJpYWJsZXMpLmZvckVhY2goKFt2YXJpYWJsZUlkLCB2YXJpYWJsZV0pID0+IHtcbiAgICAgICAgaWYgKHZhcmlhYmxlLnJlc29sdmVkVHlwZSA9PT0gJ0ZMT0FUJyAmJiAodmFyaWFibGUubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdzdHJva2UnKSB8fCB2YXJpYWJsZS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3dlaWdodCcpKSkge1xuICAgICAgICAgIGNvbnN0IGhpZXJhcmNoaWNhbE5hbWUgPSB0aGlzLnByZXNlcnZlRGVzaWduSGllcmFyY2h5KHZhcmlhYmxlLm5hbWUpO1xuICAgICAgICAgIGNvbnN0IHN0cm9rZVZhbHVlID0gdGhpcy5leHRyYWN0TnVtYmVyRnJvbVZhcmlhYmxlKHZhcmlhYmxlLCB2YXJpYWJsZXNEYXRhKTtcblxuICAgICAgICAgIGlmIChzdHJva2VWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0c1toaWVyYXJjaGljYWxOYW1lXSA9IHN0cm9rZVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYPCfk4ogRXh0cmFjdGVkICR7T2JqZWN0LmtleXMoc3Ryb2tlV2VpZ2h0cykubGVuZ3RofSBzdHJva2Ugd2VpZ2h0IHRva2VucyBmcm9tIHZhcmlhYmxlc2ApO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdHJva2VXZWlnaHRzKS5sZW5ndGggPiAwID8gc3Ryb2tlV2VpZ2h0cyA6IHRoaXMuZ2V0RmFsbGJhY2tTdHJva2VXZWlnaHRzKCk7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3ROdW1iZXJGcm9tVmFyaWFibGUodmFyaWFibGU6IGFueSwgdmFyaWFibGVzRGF0YTogRmlnbWFWYXJpYWJsZXNSZXNwb25zZSk6IG51bWJlciB8IG51bGwge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb2xsZWN0aW9uID0gdmFyaWFibGVzRGF0YS5tZXRhLnZhcmlhYmxlQ29sbGVjdGlvbnNbdmFyaWFibGUudmFyaWFibGVDb2xsZWN0aW9uSWRdO1xuICAgICAgaWYgKCFjb2xsZWN0aW9uKSByZXR1cm4gbnVsbDtcblxuICAgICAgY29uc3QgZGVmYXVsdE1vZGVJZCA9IGNvbGxlY3Rpb24uZGVmYXVsdE1vZGVJZDtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFyaWFibGUudmFsdWVzQnlNb2RlW2RlZmF1bHRNb2RlSWRdO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gIENvdWxkIG5vdCBleHRyYWN0IG51bWJlciBmcm9tIHZhcmlhYmxlICR7dmFyaWFibGUubmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgcHJpdmF0ZSBzYW5pdGl6ZVRva2VuTmFtZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBuYW1lXG4gICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgLnJlcGxhY2UoL1teYS16MC05XS9nLCAnLScpXG4gICAgICAucmVwbGFjZSgvLSsvZywgJy0nKVxuICAgICAgLnJlcGxhY2UoL14tfC0kL2csICcnKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlRva2VuUGFyc2VyIiwicGFyc2VUb2tlbnMiLCJmaWxlRGF0YSIsInN0eWxlc0RhdGEiLCJ2YXJpYWJsZXNEYXRhIiwiY29uc29sZSIsImxvZyIsInRva2VucyIsImNvbG9yIiwiZXh0cmFjdENvbG9yc0Zyb21WYXJpYWJsZXMiLCJ0eXBvZ3JhcGh5IiwiZXh0cmFjdFR5cG9ncmFwaHlGcm9tVmFyaWFibGVzIiwic3BhY2luZyIsImV4dHJhY3RTcGFjaW5nRnJvbVZhcmlhYmxlcyIsImVmZmVjdHMiLCJleHRyYWN0RWZmZWN0c0Zyb21TdHlsZXMiLCJib3JkZXJSYWRpdXMiLCJleHRyYWN0Qm9yZGVyUmFkaXVzRnJvbVZhcmlhYmxlcyIsInN0cm9rZVdlaWdodCIsImV4dHJhY3RTdHJva2VXZWlnaHRzRnJvbVZhcmlhYmxlcyIsImV4dHJhY3RDb2xvcnNGcm9tU3R5bGVzIiwiY29sb3JzIiwiZmlsbFN0eWxlcyIsIm1ldGEiLCJzdHlsZXMiLCJmaWx0ZXIiLCJzdHlsZSIsInN0eWxlX3R5cGUiLCJsZW5ndGgiLCJoaWVyYXJjaGljYWxOYW1lIiwicHJlc2VydmVEZXNpZ25IaWVyYXJjaHkiLCJuYW1lIiwiY29sb3JWYWx1ZSIsImV4dHJhY3RDb2xvckZyb21TdHlsZSIsIk9iamVjdCIsImtleXMiLCJnZXRGYWxsYmFja0NvbG9ycyIsInZhcmlhYmxlcyIsImVudHJpZXMiLCJmb3JFYWNoIiwidmFyaWFibGVJZCIsInZhcmlhYmxlIiwicmVzb2x2ZWRUeXBlIiwiZXh0cmFjdENvbG9yRnJvbVZhcmlhYmxlIiwiZmFsbGJhY2tDb2xvcnMiLCJjb2xsZWN0aW9uIiwidmFyaWFibGVDb2xsZWN0aW9ucyIsInZhcmlhYmxlQ29sbGVjdGlvbklkIiwiZGVmYXVsdE1vZGVJZCIsInZhbHVlc0J5TW9kZSIsInIiLCJ1bmRlZmluZWQiLCJnIiwiYiIsInJnYlRvSGV4IiwiZXJyb3IiLCJrZXkiLCJzdHlsZURhdGEiLCJleHRyYWN0Q29sb3JWYWx1ZUZyb21TdHlsZURhdGEiLCJmaWxscyIsImZpbGwiLCJ0eXBlIiwic3R5bGVOYW1lIiwic3BsaXQiLCJtYXAiLCJwYXJ0IiwidHJpbSIsInNhbml0aXplVG9rZW5OYW1lIiwiam9pbiIsInRvTG93ZXJDYXNlIiwidHJhdmVyc2VOb2Rlc0ZvckNvbG9ycyIsIm5vZGUiLCJjb2xvckNvdW50cyIsIkFycmF5IiwiaXNBcnJheSIsImhleENvbG9yIiwic3Ryb2tlcyIsInN0cm9rZSIsImNoaWxkcmVuIiwiY2hpbGQiLCJ0b0hleCIsImMiLCJoZXgiLCJNYXRoIiwicm91bmQiLCJ0b1N0cmluZyIsInRvVXBwZXJDYXNlIiwiZ2VuZXJhdGVDb2xvclRva2VuTmFtZSIsImluZGV4IiwiY291bnQiLCJjb2xvckFuYWx5c2lzIiwiYW5hbHl6ZUNvbG9yIiwiaW5jbHVkZXMiLCJzdGFydHNXaXRoIiwiY2F0ZWdvcnkiLCJwcmltYXJ5Iiwic2Vjb25kYXJ5IiwiYWNjZW50IiwibmV1dHJhbCIsImV4dHJhY3RUeXBvZ3JhcGh5RnJvbVN0eWxlcyIsInRleHRTdHlsZXMiLCJ0eXBvZ3JhcGh5UHJvcGVydGllcyIsImV4dHJhY3RUeXBvZ3JhcGh5RnJvbVN0eWxlIiwiZGVzY3JpcHRpb24iLCJnZXRGYWxsYmFja1R5cG9ncmFwaHkiLCJleHRyYWN0VHlwb2dyYXBoeVByb3BlcnRpZXNGcm9tU3R5bGVEYXRhIiwidGV4dFN0eWxlIiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwibGluZUhlaWdodCIsImxpbmVIZWlnaHRQeCIsImxpbmVIZWlnaHRQZXJjZW50IiwiZm9udEZhbWlseSIsImxldHRlclNwYWNpbmciLCJ0ZXh0VHJhbnNmb3JtIiwidGV4dENhc2UiLCJ0cmF2ZXJzZU5vZGVzRm9yVHlwb2dyYXBoeSIsInN0eWxlS2V5IiwiZ2VuZXJhdGVUeXBvZ3JhcGh5S2V5IiwiZXh0cmFjdFNwYWNpbmciLCJzcGFjaW5nQ291bnRzIiwidHJhdmVyc2VOb2Rlc0ZvclNwYWNpbmciLCJkb2N1bWVudCIsInNvcnQiLCJhIiwic2xpY2UiLCJzcGFjZSIsInRva2VuTmFtZSIsImdlbmVyYXRlU3BhY2luZ05hbWUiLCJOdW1iZXIiLCJnZXRGYWxsYmFja1NwYWNpbmciLCJsYXlvdXRNb2RlIiwiaXRlbVNwYWNpbmciLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdUb3AiLCJ4cyIsInNtIiwibWQiLCJsZyIsInhsIiwiZWZmZWN0U3R5bGVzIiwiZWZmZWN0UHJvcGVydGllcyIsImV4dHJhY3RFZmZlY3RGcm9tU3R5bGUiLCJ2YXJpYWJsZUVmZmVjdHMiLCJleHRyYWN0RWZmZWN0c0Zyb21WYXJpYWJsZXMiLCJhc3NpZ24iLCJnZXRGYWxsYmFja0VmZmVjdHMiLCJzdHlsZUlkIiwic3R5bGVUeXBlIiwiZXh0cmFjdEVmZmVjdFByb3BlcnRpZXNGcm9tU3R5bGVEYXRhIiwiZWZmZWN0IiwicmVwbGFjZSIsIngiLCJvZmZzZXQiLCJ5IiwiYmx1ciIsInJhZGl1cyIsInNwcmVhZCIsInJnYmFUb1N0cmluZyIsInRyYXZlcnNlTm9kZXNGb3JFZmZlY3RzIiwiZWZmZWN0c0ZvdW5kIiwicHVzaCIsImdlbmVyYXRlRWZmZWN0TmFtZSIsImV4dHJhY3RCb3JkZXJSYWRpdXMiLCJyYWRpdXNDb3VudHMiLCJ0cmF2ZXJzZU5vZGVzRm9yQm9yZGVyUmFkaXVzIiwiZ2VuZXJhdGVCb3JkZXJSYWRpdXNOYW1lIiwiZ2V0RmFsbGJhY2tCb3JkZXJSYWRpdXMiLCJjb3JuZXJSYWRpdXMiLCJyZWN0YW5nbGVDb3JuZXJSYWRpaSIsIm5vbmUiLCJmdWxsIiwiZXh0cmFjdFN0cm9rZVdlaWdodHMiLCJzdHJva2VXZWlnaHRzIiwid2VpZ2h0Q291bnRzIiwidHJhdmVyc2VOb2Rlc0ZvclN0cm9rZXMiLCJ3ZWlnaHQiLCJnZW5lcmF0ZVN0cm9rZVdlaWdodE5hbWUiLCJnZXRGYWxsYmFja1N0cm9rZVdlaWdodHMiLCJ0aGluIiwibm9ybWFsIiwidGhpY2siLCJzcGFjaW5nVmFsdWUiLCJleHRyYWN0TnVtYmVyRnJvbVZhcmlhYmxlIiwicmFkaXVzVmFsdWUiLCJzdHJva2VWYWx1ZSIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/processors/tokenParser.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/extractor.ts":
/*!***********************************!*\
  !*** ./src/services/extractor.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtractorService: () => (/* binding */ ExtractorService)\n/* harmony export */ });\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _figma_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./figma-api */ \"(rsc)/./src/services/figma-api.ts\");\n/* harmony import */ var _processors_tokenParser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../processors/tokenParser */ \"(rsc)/./src/processors/tokenParser.ts\");\n/* harmony import */ var _processors_componentParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../processors/componentParser */ \"(rsc)/./src/processors/componentParser.ts\");\n\n\n\n\n\nclass ExtractorService {\n    constructor(){\n        this.figmaApi = new _figma_api__WEBPACK_IMPORTED_MODULE_2__.FigmaApiService();\n        this.tokenParser = new _processors_tokenParser__WEBPACK_IMPORTED_MODULE_3__.TokenParser();\n        this.componentParser = new _processors_componentParser__WEBPACK_IMPORTED_MODULE_4__.ComponentParser();\n    }\n    async extractFromFigma(fileKey, outputDir = \"./output\") {\n        try {\n            console.log(\"\\uD83D\\uDD04 Fetching Figma file data...\");\n            // Fetch data from Figma API\n            const [fileData, stylesData] = await Promise.all([\n                this.figmaApi.getFile(fileKey),\n                this.figmaApi.getFileStyles(fileKey)\n            ]);\n            // Try to fetch file-specific components, but make it optional (may fail with 404 for some files)\n            let componentsData;\n            try {\n                componentsData = await this.figmaApi.getFileComponents(fileKey);\n            } catch (error) {\n                console.log(\"⚠️  Could not fetch file components (using document components instead)\");\n                componentsData = {\n                    meta: {\n                        components: []\n                    }\n                };\n            }\n            // Try to fetch local variables\n            let variablesData;\n            try {\n                variablesData = await this.figmaApi.getLocalVariables(fileKey);\n                console.log(`🔧 Found ${Object.keys(variablesData.meta.variables || {}).length} local variables`);\n                console.log(`📚 Found ${Object.keys(variablesData.meta.variableCollections || {}).length} variable collections`);\n            } catch (error) {\n                console.log(\"⚠️  Could not fetch local variables (may not be available)\");\n                variablesData = {\n                    meta: {\n                        variables: {},\n                        variableCollections: {}\n                    }\n                };\n            }\n            console.log(\"✅ Successfully fetched Figma data\");\n            console.log(`📄 File: ${fileData.name}`);\n            console.log(`🎨 Styles found: ${stylesData.meta.styles.length}`);\n            console.log(`🧩 Components found: ${componentsData.meta.components.length}`);\n            // Debug: Let's see what data structure we have for variables\n            console.log(\"\\uD83D\\uDD0D Debugging file data structure...\");\n            console.log(\"Available top-level properties:\", Object.keys(fileData));\n            if (fileData.styles) {\n                console.log(\"\\uD83D\\uDCCB Styles object keys:\", Object.keys(fileData.styles));\n            }\n            // Check if there are any other properties that might contain variables\n            [\n                \"variables\",\n                \"localVariables\",\n                \"variableCollections\"\n            ].forEach((prop)=>{\n                if (fileData[prop]) {\n                    console.log(`🔧 Found ${prop}:`, typeof fileData[prop], Object.keys(fileData[prop] || {}));\n                }\n            });\n            // Debug components data in file\n            console.log(\"\\uD83E\\uDDE9 Debugging components in file data:\");\n            if (fileData.components && typeof fileData.components === \"object\") {\n                const componentKeys = Object.keys(fileData.components);\n                console.log(`📦 Found ${componentKeys.length} components in file data:`, componentKeys);\n                // Show first few components for debugging\n                componentKeys.slice(0, 3).forEach((key)=>{\n                    const comp = fileData.components[key];\n                    console.log(`  - Component ${key}:`, {\n                        name: comp.name,\n                        type: comp.type,\n                        description: comp.description || \"No description\"\n                    });\n                });\n            }\n            if (fileData.componentSets && typeof fileData.componentSets === \"object\") {\n                const componentSetKeys = Object.keys(fileData.componentSets);\n                console.log(`📚 Found ${componentSetKeys.length} component sets in file data:`, componentSetKeys);\n            }\n            // Parse design tokens\n            console.log(\"\\uD83D\\uDD04 Parsing design tokens...\");\n            const designTokens = this.tokenParser.parseTokens(fileData, stylesData, variablesData);\n            // Parse component specs\n            console.log(\"\\uD83D\\uDD04 Parsing component specifications...\");\n            const componentSpecs = this.componentParser.parseComponents(fileData, componentsData);\n            // Ensure output directory exists\n            await this.ensureDirectoryExists(outputDir);\n            // Write JSON files\n            await this.writeJsonFile(path__WEBPACK_IMPORTED_MODULE_1__.join(outputDir, \"design-tokens.json\"), designTokens);\n            await this.writeJsonFile(path__WEBPACK_IMPORTED_MODULE_1__.join(outputDir, \"component-specs.json\"), componentSpecs);\n            console.log(\"✅ Successfully generated files:\");\n            console.log(`  📁 ${path__WEBPACK_IMPORTED_MODULE_1__.join(outputDir, \"design-tokens.json\")}`);\n            console.log(`  📁 ${path__WEBPACK_IMPORTED_MODULE_1__.join(outputDir, \"component-specs.json\")}`);\n        } catch (error) {\n            console.error(\"❌ Error during extraction:\", error);\n            throw error;\n        }\n    }\n    async ensureDirectoryExists(dirPath) {\n        try {\n            await fs_promises__WEBPACK_IMPORTED_MODULE_0__.access(dirPath);\n        } catch  {\n            await fs_promises__WEBPACK_IMPORTED_MODULE_0__.mkdir(dirPath, {\n                recursive: true\n            });\n        }\n    }\n    async writeJsonFile(filePath, data) {\n        const jsonContent = JSON.stringify(data, null, 2);\n        await fs_promises__WEBPACK_IMPORTED_MODULE_0__.writeFile(filePath, jsonContent, \"utf-8\");\n    }\n    // New method for web API - returns data instead of writing files\n    async extractDataFromFigma(fileKey) {\n        try {\n            console.log(\"\\uD83D\\uDD04 Fetching Figma file data...\");\n            // Fetch data from Figma API\n            const [fileData, stylesData] = await Promise.all([\n                this.figmaApi.getFile(fileKey),\n                this.figmaApi.getFileStyles(fileKey)\n            ]);\n            // Try to fetch file-specific components, but make it optional (may fail with 404 for some files)\n            let componentsData;\n            try {\n                componentsData = await this.figmaApi.getFileComponents(fileKey);\n            } catch (error) {\n                console.log(\"⚠️  Could not fetch file components (using document components instead)\");\n                componentsData = {\n                    meta: {\n                        components: []\n                    }\n                };\n            }\n            // Try to fetch local variables\n            let variablesData;\n            try {\n                variablesData = await this.figmaApi.getLocalVariables(fileKey);\n                console.log(`🔧 Found ${Object.keys(variablesData.meta.variables || {}).length} local variables`);\n                console.log(`📚 Found ${Object.keys(variablesData.meta.variableCollections || {}).length} variable collections`);\n            } catch (error) {\n                console.log(\"⚠️  Could not fetch local variables (may not be available)\");\n                variablesData = {\n                    meta: {\n                        variables: {},\n                        variableCollections: {}\n                    }\n                };\n            }\n            console.log(\"✅ Successfully fetched Figma data\");\n            console.log(`📄 File: ${fileData.name}`);\n            console.log(`🎨 Styles found: ${stylesData.meta.styles.length}`);\n            console.log(`🧩 Components found: ${componentsData.meta.components.length}`);\n            // Parse design tokens\n            console.log(\"\\uD83D\\uDD04 Parsing design tokens...\");\n            const designTokens = this.tokenParser.parseTokens(fileData, stylesData, variablesData);\n            // Parse component specs\n            console.log(\"\\uD83D\\uDD04 Parsing component specifications...\");\n            const componentSpecs = this.componentParser.parseComponents(fileData, componentsData);\n            console.log(\"✅ Successfully parsed data\");\n            return {\n                designTokens,\n                componentSpecs\n            };\n        } catch (error) {\n            console.error(\"❌ Error during extraction:\", error);\n            throw error;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFFM0Usc0JBQXNCO1lBQ3RCbEIsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTStCLGVBQWUsSUFBSSxDQUFDckMsV0FBVyxDQUFDc0MsV0FBVyxDQUFDL0IsVUFBVUMsWUFBWVU7WUFFeEUsd0JBQXdCO1lBQ3hCYixRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNaUMsaUJBQWlCLElBQUksQ0FBQ3RDLGVBQWUsQ0FBQ3VDLGVBQWUsQ0FBQ2pDLFVBQVVNO1lBRXRFUixRQUFRQyxHQUFHLENBQUM7WUFFWixPQUFPO2dCQUNMK0I7Z0JBQ0FFO1lBQ0Y7UUFFRixFQUFFLE9BQU94QixPQUFPO1lBQ2RWLFFBQVFVLEtBQUssQ0FBQyw4QkFBOEJBO1lBQzVDLE1BQU1BO1FBQ1I7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmlnbWEtZGVzaWduLWV4dHJhY3Rvci8uL3NyYy9zZXJ2aWNlcy9leHRyYWN0b3IudHM/ZmQ1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcy9wcm9taXNlcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgRmlnbWFBcGlTZXJ2aWNlLCBGaWdtYVZhcmlhYmxlc1Jlc3BvbnNlIH0gZnJvbSAnLi9maWdtYS1hcGknO1xuaW1wb3J0IHsgVG9rZW5QYXJzZXIsIERlc2lnblRva2VucyB9IGZyb20gJy4uL3Byb2Nlc3NvcnMvdG9rZW5QYXJzZXInO1xuaW1wb3J0IHsgQ29tcG9uZW50UGFyc2VyLCBDb21wb25lbnRTcGVjcyB9IGZyb20gJy4uL3Byb2Nlc3NvcnMvY29tcG9uZW50UGFyc2VyJztcblxuZXhwb3J0IGNsYXNzIEV4dHJhY3RvclNlcnZpY2Uge1xuICBwcml2YXRlIGZpZ21hQXBpOiBGaWdtYUFwaVNlcnZpY2U7XG4gIHByaXZhdGUgdG9rZW5QYXJzZXI6IFRva2VuUGFyc2VyO1xuICBwcml2YXRlIGNvbXBvbmVudFBhcnNlcjogQ29tcG9uZW50UGFyc2VyO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZmlnbWFBcGkgPSBuZXcgRmlnbWFBcGlTZXJ2aWNlKCk7XG4gICAgdGhpcy50b2tlblBhcnNlciA9IG5ldyBUb2tlblBhcnNlcigpO1xuICAgIHRoaXMuY29tcG9uZW50UGFyc2VyID0gbmV3IENvbXBvbmVudFBhcnNlcigpO1xuICB9XG5cbiAgYXN5bmMgZXh0cmFjdEZyb21GaWdtYShmaWxlS2V5OiBzdHJpbmcsIG91dHB1dERpcjogc3RyaW5nID0gJy4vb3V0cHV0Jyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBGZXRjaGluZyBGaWdtYSBmaWxlIGRhdGEuLi4nKTtcblxuICAgICAgLy8gRmV0Y2ggZGF0YSBmcm9tIEZpZ21hIEFQSVxuICAgICAgY29uc3QgW2ZpbGVEYXRhLCBzdHlsZXNEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5maWdtYUFwaS5nZXRGaWxlKGZpbGVLZXkpLFxuICAgICAgICB0aGlzLmZpZ21hQXBpLmdldEZpbGVTdHlsZXMoZmlsZUtleSlcbiAgICAgIF0pO1xuXG4gICAgICAvLyBUcnkgdG8gZmV0Y2ggZmlsZS1zcGVjaWZpYyBjb21wb25lbnRzLCBidXQgbWFrZSBpdCBvcHRpb25hbCAobWF5IGZhaWwgd2l0aCA0MDQgZm9yIHNvbWUgZmlsZXMpXG4gICAgICBsZXQgY29tcG9uZW50c0RhdGE7XG4gICAgICB0cnkge1xuICAgICAgICBjb21wb25lbnRzRGF0YSA9IGF3YWl0IHRoaXMuZmlnbWFBcGkuZ2V0RmlsZUNvbXBvbmVudHMoZmlsZUtleSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPICBDb3VsZCBub3QgZmV0Y2ggZmlsZSBjb21wb25lbnRzICh1c2luZyBkb2N1bWVudCBjb21wb25lbnRzIGluc3RlYWQpJyk7XG4gICAgICAgIGNvbXBvbmVudHNEYXRhID0geyBtZXRhOiB7IGNvbXBvbmVudHM6IFtdIH0gfTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJ5IHRvIGZldGNoIGxvY2FsIHZhcmlhYmxlc1xuICAgICAgbGV0IHZhcmlhYmxlc0RhdGE7XG4gICAgICB0cnkge1xuICAgICAgICB2YXJpYWJsZXNEYXRhID0gYXdhaXQgdGhpcy5maWdtYUFwaS5nZXRMb2NhbFZhcmlhYmxlcyhmaWxlS2V5KTtcbiAgICAgICAgY29uc29sZS5sb2coYPCflKcgRm91bmQgJHtPYmplY3Qua2V5cyh2YXJpYWJsZXNEYXRhLm1ldGEudmFyaWFibGVzIHx8IHt9KS5sZW5ndGh9IGxvY2FsIHZhcmlhYmxlc2ApO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+TmiBGb3VuZCAke09iamVjdC5rZXlzKHZhcmlhYmxlc0RhdGEubWV0YS52YXJpYWJsZUNvbGxlY3Rpb25zIHx8IHt9KS5sZW5ndGh9IHZhcmlhYmxlIGNvbGxlY3Rpb25zYCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPICBDb3VsZCBub3QgZmV0Y2ggbG9jYWwgdmFyaWFibGVzIChtYXkgbm90IGJlIGF2YWlsYWJsZSknKTtcbiAgICAgICAgdmFyaWFibGVzRGF0YSA9IHsgbWV0YTogeyB2YXJpYWJsZXM6IHt9LCB2YXJpYWJsZUNvbGxlY3Rpb25zOiB7fSB9IH07XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgU3VjY2Vzc2Z1bGx5IGZldGNoZWQgRmlnbWEgZGF0YScpO1xuICAgICAgY29uc29sZS5sb2coYPCfk4QgRmlsZTogJHtmaWxlRGF0YS5uYW1lfWApO1xuICAgICAgY29uc29sZS5sb2coYPCfjqggU3R5bGVzIGZvdW5kOiAke3N0eWxlc0RhdGEubWV0YS5zdHlsZXMubGVuZ3RofWApO1xuICAgICAgY29uc29sZS5sb2coYPCfp6kgQ29tcG9uZW50cyBmb3VuZDogJHtjb21wb25lbnRzRGF0YS5tZXRhLmNvbXBvbmVudHMubGVuZ3RofWApO1xuXG4gICAgICAvLyBEZWJ1ZzogTGV0J3Mgc2VlIHdoYXQgZGF0YSBzdHJ1Y3R1cmUgd2UgaGF2ZSBmb3IgdmFyaWFibGVzXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBEZWJ1Z2dpbmcgZmlsZSBkYXRhIHN0cnVjdHVyZS4uLicpO1xuICAgICAgY29uc29sZS5sb2coJ0F2YWlsYWJsZSB0b3AtbGV2ZWwgcHJvcGVydGllczonLCBPYmplY3Qua2V5cyhmaWxlRGF0YSkpO1xuXG4gICAgICBpZiAoZmlsZURhdGEuc3R5bGVzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OLIFN0eWxlcyBvYmplY3Qga2V5czonLCBPYmplY3Qua2V5cyhmaWxlRGF0YS5zdHlsZXMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIGFueSBvdGhlciBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgY29udGFpbiB2YXJpYWJsZXNcbiAgICAgIFsndmFyaWFibGVzJywgJ2xvY2FsVmFyaWFibGVzJywgJ3ZhcmlhYmxlQ29sbGVjdGlvbnMnXS5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICBpZiAoKGZpbGVEYXRhIGFzIGFueSlbcHJvcF0pIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UpyBGb3VuZCAke3Byb3B9OmAsIHR5cGVvZiAoZmlsZURhdGEgYXMgYW55KVtwcm9wXSwgT2JqZWN0LmtleXMoKGZpbGVEYXRhIGFzIGFueSlbcHJvcF0gfHwge30pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIERlYnVnIGNvbXBvbmVudHMgZGF0YSBpbiBmaWxlXG4gICAgICBjb25zb2xlLmxvZygn8J+nqSBEZWJ1Z2dpbmcgY29tcG9uZW50cyBpbiBmaWxlIGRhdGE6Jyk7XG4gICAgICBpZiAoZmlsZURhdGEuY29tcG9uZW50cyAmJiB0eXBlb2YgZmlsZURhdGEuY29tcG9uZW50cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50S2V5cyA9IE9iamVjdC5rZXlzKGZpbGVEYXRhLmNvbXBvbmVudHMpO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+TpiBGb3VuZCAke2NvbXBvbmVudEtleXMubGVuZ3RofSBjb21wb25lbnRzIGluIGZpbGUgZGF0YTpgLCBjb21wb25lbnRLZXlzKTtcblxuICAgICAgICAvLyBTaG93IGZpcnN0IGZldyBjb21wb25lbnRzIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgY29tcG9uZW50S2V5cy5zbGljZSgwLCAzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgY29uc3QgY29tcCA9IGZpbGVEYXRhLmNvbXBvbmVudHNba2V5XTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgICAtIENvbXBvbmVudCAke2tleX06YCwge1xuICAgICAgICAgICAgbmFtZTogY29tcC5uYW1lLFxuICAgICAgICAgICAgdHlwZTogY29tcC50eXBlLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGNvbXAuZGVzY3JpcHRpb24gfHwgJ05vIGRlc2NyaXB0aW9uJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGVEYXRhLmNvbXBvbmVudFNldHMgJiYgdHlwZW9mIGZpbGVEYXRhLmNvbXBvbmVudFNldHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFNldEtleXMgPSBPYmplY3Qua2V5cyhmaWxlRGF0YS5jb21wb25lbnRTZXRzKTtcbiAgICAgICAgY29uc29sZS5sb2coYPCfk5ogRm91bmQgJHtjb21wb25lbnRTZXRLZXlzLmxlbmd0aH0gY29tcG9uZW50IHNldHMgaW4gZmlsZSBkYXRhOmAsIGNvbXBvbmVudFNldEtleXMpO1xuICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQYXJzZSBkZXNpZ24gdG9rZW5zXG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBQYXJzaW5nIGRlc2lnbiB0b2tlbnMuLi4nKTtcbiAgICAgIGNvbnN0IGRlc2lnblRva2VuczogRGVzaWduVG9rZW5zID0gdGhpcy50b2tlblBhcnNlci5wYXJzZVRva2VucyhmaWxlRGF0YSwgc3R5bGVzRGF0YSwgdmFyaWFibGVzRGF0YSk7XG5cbiAgICAgIC8vIFBhcnNlIGNvbXBvbmVudCBzcGVjc1xuICAgICAgY29uc29sZS5sb2coJ/CflIQgUGFyc2luZyBjb21wb25lbnQgc3BlY2lmaWNhdGlvbnMuLi4nKTtcbiAgICAgIGNvbnN0IGNvbXBvbmVudFNwZWNzOiBDb21wb25lbnRTcGVjcyA9IHRoaXMuY29tcG9uZW50UGFyc2VyLnBhcnNlQ29tcG9uZW50cyhmaWxlRGF0YSwgY29tcG9uZW50c0RhdGEpO1xuXG4gICAgICAvLyBFbnN1cmUgb3V0cHV0IGRpcmVjdG9yeSBleGlzdHNcbiAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRGlyZWN0b3J5RXhpc3RzKG91dHB1dERpcik7XG5cbiAgICAgIC8vIFdyaXRlIEpTT04gZmlsZXNcbiAgICAgIGF3YWl0IHRoaXMud3JpdGVKc29uRmlsZShwYXRoLmpvaW4ob3V0cHV0RGlyLCAnZGVzaWduLXRva2Vucy5qc29uJyksIGRlc2lnblRva2Vucyk7XG4gICAgICBhd2FpdCB0aGlzLndyaXRlSnNvbkZpbGUocGF0aC5qb2luKG91dHB1dERpciwgJ2NvbXBvbmVudC1zcGVjcy5qc29uJyksIGNvbXBvbmVudFNwZWNzKTtcblxuICAgICAgY29uc29sZS5sb2coJ+KchSBTdWNjZXNzZnVsbHkgZ2VuZXJhdGVkIGZpbGVzOicpO1xuICAgICAgY29uc29sZS5sb2coYCAg8J+TgSAke3BhdGguam9pbihvdXRwdXREaXIsICdkZXNpZ24tdG9rZW5zLmpzb24nKX1gKTtcbiAgICAgIGNvbnNvbGUubG9nKGAgIPCfk4EgJHtwYXRoLmpvaW4ob3V0cHV0RGlyLCAnY29tcG9uZW50LXNwZWNzLmpzb24nKX1gKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZHVyaW5nIGV4dHJhY3Rpb246JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBlbnN1cmVEaXJlY3RvcnlFeGlzdHMoZGlyUGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzLmFjY2VzcyhkaXJQYXRoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGF3YWl0IGZzLm1rZGlyKGRpclBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgd3JpdGVKc29uRmlsZShmaWxlUGF0aDogc3RyaW5nLCBkYXRhOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBqc29uQ29udGVudCA9IEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShmaWxlUGF0aCwganNvbkNvbnRlbnQsICd1dGYtOCcpO1xuICB9XG5cbiAgLy8gTmV3IG1ldGhvZCBmb3Igd2ViIEFQSSAtIHJldHVybnMgZGF0YSBpbnN0ZWFkIG9mIHdyaXRpbmcgZmlsZXNcbiAgYXN5bmMgZXh0cmFjdERhdGFGcm9tRmlnbWEoZmlsZUtleTogc3RyaW5nKTogUHJvbWlzZTx7XG4gICAgZGVzaWduVG9rZW5zOiBhbnk7XG4gICAgY29tcG9uZW50U3BlY3M6IGFueTtcbiAgfT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBGZXRjaGluZyBGaWdtYSBmaWxlIGRhdGEuLi4nKTtcblxuICAgICAgLy8gRmV0Y2ggZGF0YSBmcm9tIEZpZ21hIEFQSVxuICAgICAgY29uc3QgW2ZpbGVEYXRhLCBzdHlsZXNEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5maWdtYUFwaS5nZXRGaWxlKGZpbGVLZXkpLFxuICAgICAgICB0aGlzLmZpZ21hQXBpLmdldEZpbGVTdHlsZXMoZmlsZUtleSlcbiAgICAgIF0pO1xuXG4gICAgICAvLyBUcnkgdG8gZmV0Y2ggZmlsZS1zcGVjaWZpYyBjb21wb25lbnRzLCBidXQgbWFrZSBpdCBvcHRpb25hbCAobWF5IGZhaWwgd2l0aCA0MDQgZm9yIHNvbWUgZmlsZXMpXG4gICAgICBsZXQgY29tcG9uZW50c0RhdGE7XG4gICAgICB0cnkge1xuICAgICAgICBjb21wb25lbnRzRGF0YSA9IGF3YWl0IHRoaXMuZmlnbWFBcGkuZ2V0RmlsZUNvbXBvbmVudHMoZmlsZUtleSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPICBDb3VsZCBub3QgZmV0Y2ggZmlsZSBjb21wb25lbnRzICh1c2luZyBkb2N1bWVudCBjb21wb25lbnRzIGluc3RlYWQpJyk7XG4gICAgICAgIGNvbXBvbmVudHNEYXRhID0geyBtZXRhOiB7IGNvbXBvbmVudHM6IFtdIH0gfTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJ5IHRvIGZldGNoIGxvY2FsIHZhcmlhYmxlc1xuICAgICAgbGV0IHZhcmlhYmxlc0RhdGE7XG4gICAgICB0cnkge1xuICAgICAgICB2YXJpYWJsZXNEYXRhID0gYXdhaXQgdGhpcy5maWdtYUFwaS5nZXRMb2NhbFZhcmlhYmxlcyhmaWxlS2V5KTtcbiAgICAgICAgY29uc29sZS5sb2coYPCflKcgRm91bmQgJHtPYmplY3Qua2V5cyh2YXJpYWJsZXNEYXRhLm1ldGEudmFyaWFibGVzIHx8IHt9KS5sZW5ndGh9IGxvY2FsIHZhcmlhYmxlc2ApO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+TmiBGb3VuZCAke09iamVjdC5rZXlzKHZhcmlhYmxlc0RhdGEubWV0YS52YXJpYWJsZUNvbGxlY3Rpb25zIHx8IHt9KS5sZW5ndGh9IHZhcmlhYmxlIGNvbGxlY3Rpb25zYCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPICBDb3VsZCBub3QgZmV0Y2ggbG9jYWwgdmFyaWFibGVzIChtYXkgbm90IGJlIGF2YWlsYWJsZSknKTtcbiAgICAgICAgdmFyaWFibGVzRGF0YSA9IHsgbWV0YTogeyB2YXJpYWJsZXM6IHt9LCB2YXJpYWJsZUNvbGxlY3Rpb25zOiB7fSB9IH07XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgU3VjY2Vzc2Z1bGx5IGZldGNoZWQgRmlnbWEgZGF0YScpO1xuICAgICAgY29uc29sZS5sb2coYPCfk4QgRmlsZTogJHtmaWxlRGF0YS5uYW1lfWApO1xuICAgICAgY29uc29sZS5sb2coYPCfjqggU3R5bGVzIGZvdW5kOiAke3N0eWxlc0RhdGEubWV0YS5zdHlsZXMubGVuZ3RofWApO1xuICAgICAgY29uc29sZS5sb2coYPCfp6kgQ29tcG9uZW50cyBmb3VuZDogJHtjb21wb25lbnRzRGF0YS5tZXRhLmNvbXBvbmVudHMubGVuZ3RofWApO1xuXG4gICAgICAvLyBQYXJzZSBkZXNpZ24gdG9rZW5zXG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBQYXJzaW5nIGRlc2lnbiB0b2tlbnMuLi4nKTtcbiAgICAgIGNvbnN0IGRlc2lnblRva2VucyA9IHRoaXMudG9rZW5QYXJzZXIucGFyc2VUb2tlbnMoZmlsZURhdGEsIHN0eWxlc0RhdGEsIHZhcmlhYmxlc0RhdGEpO1xuXG4gICAgICAvLyBQYXJzZSBjb21wb25lbnQgc3BlY3NcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFBhcnNpbmcgY29tcG9uZW50IHNwZWNpZmljYXRpb25zLi4uJyk7XG4gICAgICBjb25zdCBjb21wb25lbnRTcGVjcyA9IHRoaXMuY29tcG9uZW50UGFyc2VyLnBhcnNlQ29tcG9uZW50cyhmaWxlRGF0YSwgY29tcG9uZW50c0RhdGEpO1xuXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFN1Y2Nlc3NmdWxseSBwYXJzZWQgZGF0YScpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZXNpZ25Ub2tlbnMsXG4gICAgICAgIGNvbXBvbmVudFNwZWNzXG4gICAgICB9O1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBkdXJpbmcgZXh0cmFjdGlvbjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJmcyIsInBhdGgiLCJGaWdtYUFwaVNlcnZpY2UiLCJUb2tlblBhcnNlciIsIkNvbXBvbmVudFBhcnNlciIsIkV4dHJhY3RvclNlcnZpY2UiLCJjb25zdHJ1Y3RvciIsImZpZ21hQXBpIiwidG9rZW5QYXJzZXIiLCJjb21wb25lbnRQYXJzZXIiLCJleHRyYWN0RnJvbUZpZ21hIiwiZmlsZUtleSIsIm91dHB1dERpciIsImNvbnNvbGUiLCJsb2ciLCJmaWxlRGF0YSIsInN0eWxlc0RhdGEiLCJQcm9taXNlIiwiYWxsIiwiZ2V0RmlsZSIsImdldEZpbGVTdHlsZXMiLCJjb21wb25lbnRzRGF0YSIsImdldEZpbGVDb21wb25lbnRzIiwiZXJyb3IiLCJtZXRhIiwiY29tcG9uZW50cyIsInZhcmlhYmxlc0RhdGEiLCJnZXRMb2NhbFZhcmlhYmxlcyIsIk9iamVjdCIsImtleXMiLCJ2YXJpYWJsZXMiLCJsZW5ndGgiLCJ2YXJpYWJsZUNvbGxlY3Rpb25zIiwibmFtZSIsInN0eWxlcyIsImZvckVhY2giLCJwcm9wIiwiY29tcG9uZW50S2V5cyIsInNsaWNlIiwia2V5IiwiY29tcCIsInR5cGUiLCJkZXNjcmlwdGlvbiIsImNvbXBvbmVudFNldHMiLCJjb21wb25lbnRTZXRLZXlzIiwiZGVzaWduVG9rZW5zIiwicGFyc2VUb2tlbnMiLCJjb21wb25lbnRTcGVjcyIsInBhcnNlQ29tcG9uZW50cyIsImVuc3VyZURpcmVjdG9yeUV4aXN0cyIsIndyaXRlSnNvbkZpbGUiLCJqb2luIiwiZGlyUGF0aCIsImFjY2VzcyIsIm1rZGlyIiwicmVjdXJzaXZlIiwiZmlsZVBhdGgiLCJkYXRhIiwianNvbkNvbnRlbnQiLCJKU09OIiwic3RyaW5naWZ5Iiwid3JpdGVGaWxlIiwiZXh0cmFjdERhdGFGcm9tRmlnbWEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/services/extractor.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/figma-api.ts":
/*!***********************************!*\
  !*** ./src/services/figma-api.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FigmaApiService: () => (/* binding */ FigmaApiService)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"(rsc)/./src/config/index.ts\");\n\n\nclass FigmaApiService {\n    constructor(){\n        this.client = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n            baseURL: _config__WEBPACK_IMPORTED_MODULE_0__.config.figmaApiBaseUrl,\n            headers: {\n                \"X-Figma-Token\": _config__WEBPACK_IMPORTED_MODULE_0__.config.figmaApiToken,\n                \"Content-Type\": \"application/json\"\n            }\n        });\n    }\n    async getFile(fileKey) {\n        try {\n            const response = await this.client.get(`/files/${fileKey}`);\n            return response.data;\n        } catch (error) {\n            throw new Error(`Failed to fetch Figma file: ${error}`);\n        }\n    }\n    async getFileStyles(fileKey) {\n        try {\n            const response = await this.client.get(`/files/${fileKey}/styles`);\n            return response.data;\n        } catch (error) {\n            throw new Error(`Failed to fetch Figma file styles: ${error}`);\n        }\n    }\n    async getFileComponents(fileKey) {\n        try {\n            const response = await this.client.get(`/files/${fileKey}/components`);\n            // Console log the response for debugging\n            console.log(\"\\uD83D\\uDD0D Raw components API response:\");\n            console.log(\"Response status:\", response.status);\n            console.log(\"Response data:\", JSON.stringify(response.data, null, 2));\n            if (response.data.meta && response.data.meta.components) {\n                console.log(`📦 Found ${response.data.meta.components.length} components via API`);\n                response.data.meta.components.forEach((comp, index)=>{\n                    console.log(`  ${index + 1}. ${comp.name} (${comp.key}) - Node ID: ${comp.node_id}`);\n                });\n            }\n            return response.data;\n        } catch (error) {\n            throw new Error(`Failed to fetch Figma file components: ${error}`);\n        }\n    }\n    async getLocalVariables(fileKey) {\n        try {\n            const response = await this.client.get(`/files/${fileKey}/variables/local`);\n            return response.data;\n        } catch (error) {\n            throw new Error(`Failed to fetch Figma local variables: ${error}`);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aS50cz9mYjY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcywgeyBBeGlvc0luc3RhbmNlLCBBeGlvc1Jlc3BvbnNlIH0gZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcblxuZXhwb3J0IGludGVyZmFjZSBGaWdtYUZpbGVSZXNwb25zZSB7XG4gIG5hbWU6IHN0cmluZztcbiAgbGFzdE1vZGlmaWVkOiBzdHJpbmc7XG4gIHRodW1ibmFpbFVybDogc3RyaW5nO1xuICB2ZXJzaW9uOiBzdHJpbmc7XG4gIGRvY3VtZW50OiBhbnk7XG4gIGNvbXBvbmVudHM6IHsgW2tleTogc3RyaW5nXTogYW55IH07XG4gIGNvbXBvbmVudFNldHM6IHsgW2tleTogc3RyaW5nXTogYW55IH07XG4gIHNjaGVtYVZlcnNpb246IG51bWJlcjtcbiAgc3R5bGVzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpZ21hU3R5bGVzUmVzcG9uc2Uge1xuICBtZXRhOiB7XG4gICAgc3R5bGVzOiBBcnJheTx7XG4gICAgICBrZXk6IHN0cmluZztcbiAgICAgIGZpbGVfa2V5OiBzdHJpbmc7XG4gICAgICBub2RlX2lkOiBzdHJpbmc7XG4gICAgICBzdHlsZV90eXBlOiBzdHJpbmc7XG4gICAgICB0aHVtYm5haWxfdXJsOiBzdHJpbmc7XG4gICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgICAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICAgICAgdXBkYXRlZF9hdDogc3RyaW5nO1xuICAgIH0+O1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpZ21hQ29tcG9uZW50c1Jlc3BvbnNlIHtcbiAgbWV0YToge1xuICAgIGNvbXBvbmVudHM6IEFycmF5PHtcbiAgICAgIGtleTogc3RyaW5nO1xuICAgICAgZmlsZV9rZXk6IHN0cmluZztcbiAgICAgIG5vZGVfaWQ6IHN0cmluZztcbiAgICAgIHRodW1ibmFpbF91cmw6IHN0cmluZztcbiAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gICAgICB1cGRhdGVkX2F0OiBzdHJpbmc7XG4gICAgfT47XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlnbWFWYXJpYWJsZXNSZXNwb25zZSB7XG4gIG1ldGE6IHtcbiAgICB2YXJpYWJsZXM6IHsgW2tleTogc3RyaW5nXTogRmlnbWFWYXJpYWJsZSB9O1xuICAgIHZhcmlhYmxlQ29sbGVjdGlvbnM6IHsgW2tleTogc3RyaW5nXTogRmlnbWFWYXJpYWJsZUNvbGxlY3Rpb24gfTtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWdtYVZhcmlhYmxlIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBrZXk6IHN0cmluZztcbiAgdmFyaWFibGVDb2xsZWN0aW9uSWQ6IHN0cmluZztcbiAgcmVzb2x2ZWRUeXBlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGhpZGRlbkZyb21QdWJsaXNoaW5nOiBib29sZWFuO1xuICBzY29wZXM6IHN0cmluZ1tdO1xuICBjb2RlU3ludGF4OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICB2YWx1ZXNCeU1vZGU6IHsgW2tleTogc3RyaW5nXTogYW55IH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlnbWFWYXJpYWJsZUNvbGxlY3Rpb24ge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGtleTogc3RyaW5nO1xuICBtb2RlczogQXJyYXk8e1xuICAgIG1vZGVJZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgfT47XG4gIGRlZmF1bHRNb2RlSWQ6IHN0cmluZztcbiAgcmVtb3RlOiBib29sZWFuO1xuICBoaWRkZW5Gcm9tUHVibGlzaGluZzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIEZpZ21hQXBpU2VydmljZSB7XG4gIHByaXZhdGUgY2xpZW50OiBBeGlvc0luc3RhbmNlO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2xpZW50ID0gYXhpb3MuY3JlYXRlKHtcbiAgICAgIGJhc2VVUkw6IGNvbmZpZy5maWdtYUFwaUJhc2VVcmwsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdYLUZpZ21hLVRva2VuJzogY29uZmlnLmZpZ21hQXBpVG9rZW4sXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGdldEZpbGUoZmlsZUtleTogc3RyaW5nKTogUHJvbWlzZTxGaWdtYUZpbGVSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZTogQXhpb3NSZXNwb25zZTxGaWdtYUZpbGVSZXNwb25zZT4gPSBhd2FpdCB0aGlzLmNsaWVudC5nZXQoYC9maWxlcy8ke2ZpbGVLZXl9YCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggRmlnbWEgZmlsZTogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRGaWxlU3R5bGVzKGZpbGVLZXk6IHN0cmluZyk6IFByb21pc2U8RmlnbWFTdHlsZXNSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZTogQXhpb3NSZXNwb25zZTxGaWdtYVN0eWxlc1Jlc3BvbnNlPiA9IGF3YWl0IHRoaXMuY2xpZW50LmdldChgL2ZpbGVzLyR7ZmlsZUtleX0vc3R5bGVzYCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggRmlnbWEgZmlsZSBzdHlsZXM6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0RmlsZUNvbXBvbmVudHMoZmlsZUtleTogc3RyaW5nKTogUHJvbWlzZTxGaWdtYUNvbXBvbmVudHNSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZTogQXhpb3NSZXNwb25zZTxGaWdtYUNvbXBvbmVudHNSZXNwb25zZT4gPSBhd2FpdCB0aGlzLmNsaWVudC5nZXQoYC9maWxlcy8ke2ZpbGVLZXl9L2NvbXBvbmVudHNgKTtcblxuICAgICAgLy8gQ29uc29sZSBsb2cgdGhlIHJlc3BvbnNlIGZvciBkZWJ1Z2dpbmdcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFJhdyBjb21wb25lbnRzIEFQSSByZXNwb25zZTonKTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSBkYXRhOicsIEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmRhdGEsIG51bGwsIDIpKTtcblxuICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubWV0YSAmJiByZXNwb25zZS5kYXRhLm1ldGEuY29tcG9uZW50cykge1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+TpiBGb3VuZCAke3Jlc3BvbnNlLmRhdGEubWV0YS5jb21wb25lbnRzLmxlbmd0aH0gY29tcG9uZW50cyB2aWEgQVBJYCk7XG4gICAgICAgIHJlc3BvbnNlLmRhdGEubWV0YS5jb21wb25lbnRzLmZvckVhY2goKGNvbXAsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYCAgJHtpbmRleCArIDF9LiAke2NvbXAubmFtZX0gKCR7Y29tcC5rZXl9KSAtIE5vZGUgSUQ6ICR7Y29tcC5ub2RlX2lkfWApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIEZpZ21hIGZpbGUgY29tcG9uZW50czogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRMb2NhbFZhcmlhYmxlcyhmaWxlS2V5OiBzdHJpbmcpOiBQcm9taXNlPEZpZ21hVmFyaWFibGVzUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2U6IEF4aW9zUmVzcG9uc2U8RmlnbWFWYXJpYWJsZXNSZXNwb25zZT4gPSBhd2FpdCB0aGlzLmNsaWVudC5nZXQoYC9maWxlcy8ke2ZpbGVLZXl9L3ZhcmlhYmxlcy9sb2NhbGApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIEZpZ21hIGxvY2FsIHZhcmlhYmxlczogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJheGlvcyIsImNvbmZpZyIsIkZpZ21hQXBpU2VydmljZSIsImNvbnN0cnVjdG9yIiwiY2xpZW50IiwiY3JlYXRlIiwiYmFzZVVSTCIsImZpZ21hQXBpQmFzZVVybCIsImhlYWRlcnMiLCJmaWdtYUFwaVRva2VuIiwiZ2V0RmlsZSIsImZpbGVLZXkiLCJyZXNwb25zZSIsImdldCIsImRhdGEiLCJlcnJvciIsIkVycm9yIiwiZ2V0RmlsZVN0eWxlcyIsImdldEZpbGVDb21wb25lbnRzIiwiY29uc29sZSIsImxvZyIsInN0YXR1cyIsIkpTT04iLCJzdHJpbmdpZnkiLCJtZXRhIiwiY29tcG9uZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJjb21wIiwiaW5kZXgiLCJuYW1lIiwia2V5Iiwibm9kZV9pZCIsImdldExvY2FsVmFyaWFibGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/services/figma-api.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/axios","vendor-chunks/asynckit","vendor-chunks/math-intrinsics","vendor-chunks/es-errors","vendor-chunks/call-bind-apply-helpers","vendor-chunks/debug","vendor-chunks/get-proto","vendor-chunks/mime-db","vendor-chunks/has-symbols","vendor-chunks/gopd","vendor-chunks/function-bind","vendor-chunks/form-data","vendor-chunks/follow-redirects","vendor-chunks/dotenv","vendor-chunks/supports-color","vendor-chunks/proxy-from-env","vendor-chunks/ms","vendor-chunks/mime-types","vendor-chunks/hasown","vendor-chunks/has-tostringtag","vendor-chunks/has-flag","vendor-chunks/get-intrinsic","vendor-chunks/es-set-tostringtag","vendor-chunks/es-object-atoms","vendor-chunks/es-define-property","vendor-chunks/dunder-proto","vendor-chunks/delayed-stream","vendor-chunks/combined-stream"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fextract%2Froute&page=%2Fapi%2Fextract%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fextract%2Froute.ts&appDir=%2FUsers%2Faldunchev%2FWork%2FProjectsCode%2FAI%2Fdesign-to-code%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Faldunchev%2FWork%2FProjectsCode%2FAI%2Fdesign-to-code&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();